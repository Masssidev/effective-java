# 클래스와 인터페이스
클래스와 인터페이스는 자바 프로그래밍 언어의 핵심적 부분으로서, 추상화의 기본 단위다. 자바 언어는 클래스와 인터페이스를 설계할 때 이용할 수 있는 강력한 
요소들을 많이 갖추고 있다.
<hr/>

### 규칙 13. 클래스와 멤버의 접근 권한은 최소화하라
잘 설계된 모듈과 그렇지 못한 모듈을 구별 짓는 가장 중요한 속성 하나는 모듈 내부의 데이터를 비롯한 구현 세부사항을 다른 모듈에 잘 감추느냐의 여부다. 
이 개념은 **정보 은닉** 또는 **캡슐화**라는 용어로 알려져 있으며, 소프트웨어 설계의 기본적인 원칙 가운데 하나다

정보 은닉은 여러 가지 이유로 중요한데, 그 대부분은 정보 은닉이 시스템을 구성하는 모듈 사이의 의존성을 낮춰서, 각자 개별적으로 개발하고, 시험하고, 최적화하고, 
이해하고, 변경할 수 있도록 한다는 사실에 기초한다.
> 각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들어야 한다.
* private - 이렇게 선언된 멤버는 선언된 최상위 레벨 클래스 내부에서만 접근 가능하다.
* package-private - 이렇게 선언된 멤버는 같은 패키지 내의 아무 클래스나 사용할 수 있다. 기본 접근 권한(default access)으로 알려져 있는데, 멤버를 선언할 때 
아무런 접근 권한 수정자도 붙이지 않으면, 이 권한이 주어지기 때문이다.
* protected - 이렇게 선언된 멤버는 선언된 클래스 및 그 하위 클래스만 사용할 수 있다. 선언된 클래스와 같은 패키지에 있는 클래스에서도 사용이 가능한다.
* public - 이렇게 선언된 멤버는 어디서도 사용이 가능하다.
> 객체 필드는 절대로 public으로 선언하면 안 된다. 변경 가능 public 필드를 가진 클래스는 다중 스레드에 안전하지 않다.

* 길이가 0이 아닌 배열은 언제나 변경 가능하므로, public static final 배열 필드를 두거나, 배열 필드를 반환하는 접근자를 정의하면 안 된다.
1. public으로 선언되었던 배열은 private로 바꾸고, 변경이 불가능한 public 리스트(list)를 하나 만든다.
2. 배열은 private로 선언하고, 해당 배열을 복사해서 반환하는 public 메서드를 하나 추가한다.
<hr/>

### 규칙 14. public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라
필드를 모으는 것 말고는 아무 기능도 없는 쓰레기 클래스는 private 필드와 public 접근자 메서드로 바꾼다. 변경 가능 클래스라면 수정자 메서드도 제공해야 한다.
> public 클래스는 변경 가능 필드를 외부로 공개하면 안 된다. 변경 불가능 필드인 경우에는 외부로 공개하더라도 많이 위험하진 않지만, 그럴 필요가 있지 않다.하지만 package-private나 private로 선언된 중첩 클래스의 필드는 그 변경 가능 여부와는 상관없이 외부로 공개하는 것이 바람직할 때도 있다.
<hr/>

### 규칙 15. 변경 가능성을 최소화하라
변경 불가능(immutable) 클래스는 그 객체를 수정할 수 없는 클래스다. 객체 내부의 정보는 객체가 생성될 때 주어진 것이며, 객체가 살아 있는 동안 그대로 보존된다. 
###### 변경 불가능 클래스를 만드는 규칙
1. 객체 상태를 변경하는 메서드(수정자 메서드 등)를 제공하지 않는다.
2. 상속할 수 없도록 한다. 보통 클래스를 final로 선언하면 된다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private로 선언한다.
5. 변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다.
> * 변경 불가능 객체는 단순한다. 생성될 때 부여된 한 가지 상태만 갖는다.<br/>
> * 또한 변경 불가능 객체는 스레드에 안전할 수 밖에 없다. 따라서 변경 불가능한 객체는 자유롭게 공유할 수 있다.<br/>
> * 변경 불가능한 객체는 그 내부도 공유할 수 있다.<br/>
> * 변경 불가능 객체는 다른 객체의 구성요소로도 훌륭하다.<br/>
> * 변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점이다.

* 변경 불가능성을 보장하기 위해서는 하위 클래스 정의가 불가능하도록 해야 한다. 보통은 클래스를 final로 선언하면 되지만, 그보다 더 유연한 방법도 있다. 모든 생성자를 private나 package-private로 선언하고 public 생성자 대신 public 정적 팩터리를 제공하는 것이다.
> 변경 불가능 클래스 구현 규칙은, 어떤 메서드도 객체를 수정해서는 안 되며, 모든 필드는 final로 선언되어야 한다.

> 변경 가능한 클래스로 만들 타당한 이유가 없다면, 반드시 변경 불가능 클래스로 만들어야 한다.

> 변경 불가능한 클래스로 만들 수 없다면, 변경 가능성을 최대한 제한하라. 특별한 이유가 없다면 모든 필드는 final로 선언하라.
<hr/>

### 규칙 16. 계승하는 대신 구성하라
계승은 코드 재사용을 돕는 강력한 도구지만, 항상 최선이라고는 할 수 없다. 계승을 적절히 사용하지 못한 소프트웨어는 깨지기 쉽다.

메서드 호출과 달리, 계승은 캡슐화 원칙을 위반한다. 하위 클래스가 정상 동작하기 위해서는 상위 클래스의 구현에 의존할 수밖에 없다. 

기존 클래스를 계승하는 대신, 새로운 클래스에 기존 클래스 객체를 참조하는 private 필드를 하나 둔다. 이런 설계 기법을 구성이라고 부르는데, 기존 클래스가 새 클래스의 일부가 되기 때문이다.
> 계승은 하위 클래스가 상위 클래스의 하위 자료형이 확실한 경우에만 바람직하다.

> 계승 메커니즘은 상위 클래스의 문제를 하위 클래스에 전파시킨다. 반면 구성 기법은 그런 약점을 감추는 새로운 API를 설계할 수 있도록 해 준다.
###### 요약
계승은 강력한 도구이지만 캡슐화 원칙을 침해하므로 문제를 발생시킬 소지가 있다. 상위 클래스와 하위 클래스 사이에 IS-A 관계가 성립해도, 하위 클래스가 상위 클래스와 다른 패키지에 있거나 계승을 고려해 만들어진 상위 클래스가 아니라면, 하위 클래스는 깨지기 쉽다. 이런 문제를 피하려면 구성과 전달 기법을 사용하는 것이 좋다. 포장 클래스 구현에 적당한 인터페이스가 있다면 더욱 그렇다. 포장 클래스는 하위 클래스보다 견고할 뿐 아니라, 더 강력하다.
<hr/>

### 규칙 17. 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라
* 메서드를 재정의하면 무슨 일이 생기는지 정확하게 문서로 남겨야 한다. 재정의 가능 메서드를 내부적으로 어떻게 사용하는지 반드시 문서에 남겨야 한다.
* 효율적인 하위 클래스를 작성할 수 있도록 하려면, 클래스 내부 동작에 개입할 수 있는 훅을 신중하게 고른 protected 메서드 형태로 제공해야 한다.
* 계승을 위해 설계한 클래스를 테스트할 유일한 방법은 하위 클래스를 직접 만들어 보는 것이다.
* 계승을 허용하려면 반드시 따라야 할 제약사항
  * 생성자는 직접적이건 간접적이건 재정의 가능 메서드를 호출해서는 안 된다.
  * Cloneable이나 Serializable을 구현한다면 clone이나 readObject 메서드 안에서 직접적이건 간접적이건 재정의 가능한 메서드를 호출하지 않도록 해야 한다.
  * Serializable 인터페이스를 구현하는 계승용 클래스에 readResolve와 writeReplace 메서드가 있다면, 이 두 메서드는 private가 아니라 protected로 선언해야만 한다.
> 계승을 위해 클래스를 설계하면 클래스에 상당한 제약이 가해진다.
<hr/>

### 규칙 18. 추상 클래스 대신 인터페이스를 사용하라
* 인터페이스는 믹스인을 정의하는 데 이상적이다. 간단히 말해서 믹스인은 클래스가 "주 자료형" 이외에 추가로 구현할 수 있는 자료형으로, 어떤 선택적 기능을 제공한다는 사실을 선언하기 위해 쓰인다.
* 인터페이스는 비 계층적인 자료형 프레임워크를 만들 수 있도록 한다.
###### 요약
인터페이스는 다양한 구현이 가능한 자료형을 정의하는 일반적으로 가장 좋은 방법이다. 유연하고 강력한 API를 만드는 것보다 개선이 쉬운 API를 만드는 것이 중요한 경우는 예외다. 그런 경우에는 추상 클래스를 사용해야 하는데, 그 단점은 잘 이해하고 있어야 하며, 그 단점을 수용할 수 있는 경우로 한정해서 사용해야 한다. 중요한 인터페이스를 API에 포함시키는 경우에는 골격 구현 클래스를 함께 제공하면 어떨지 심각하게 고려해봐야 한다. 마지막으로, public 인터페이스는 극도로 주의해서 설계해야 하며, 실제로 여러 구현을 만들어 보면서 광범위하게 테스트해야 한다.
<hr/>

### 규칙 19. 인터페이스는 자료형을 정의할 때만 사용하라
인터페이스를 구현하는 클래스를 만들게 되면, 그 인터페이스는 해당 클래스의 객체를 참조할 수 있는 자료형 역할을 하게 된다. 인터페이스를 구현해 클래스를 만든다는 것은, 해당 클래스의 객체로 어떤 일을 할 수 있는지 클라이언트에게 알리는 행위다.
> 다른 목적으로 인터페이스를 정의하고 사용하는 것은 적절치 못하다.

> 인터페이스는 자료형을 정의할 때만 사용해야 한다. 특정 상수를 API의 일부로 공개할 목적으로는 적절치 않다.
<hr/>

### 규칙 20. 태그 달린 클래스 대신 클래스 계층을 활용하라
때로 두 가지 이상의 기능을 가지고 있으며, 그중 어떤 기능을 제공하는지 표시하는 태그가 달린 클래스를 만날 때가 있다. 태그 달린 클래스에는 다양한 문제가 있다. enum 선언, 태그 필드, switch 문 등의 상투적 코드가 반복되는 클래스가 만들어지며, 서로 다른 기능을 위한 코드가 한 클래스에 모여 있으니 가독성도 떨어진다. 객체를 만들 때마다 필요 없는 기능을 위한 필드도 함께 생성되므로, 메모리 요구량도 늘어난다. 
> 태그 기반 클래스는 너저분한데다 오류 발생 가능성이 높고, 효율적이지도 않다. 태그 기반 클래스는 클래스 계층을 얼기설기 흉내 낸 것일 뿐이다.

태그 기반 클래스를 클래스 계층으로 변환하려면, 먼저 태그 값에 따라 달리 동작하는 메서드를 추상 메서드로 선언하는 추상클래스를 정의해야 한다. 이 추상 클래스를 클래스 계층 맨 꼭대기에 두고, 태그 값에 좌우되지 않는 메서드는 전부 이 클래스에 넣는다. 모든 기능에 공통되는 데이터 필드도 전부 이 클래스에 넣는다. 그 다음 태그 기반 클래스가 제공하던 각각의 기능을 위의 최상위 클래스의 객체 생성 가능 하위 클래스로 정의한다. 최상위 클래스에 선언된 추상 메서드는 각 클래스에 구현해서 넣는다. 
> 클래스 계층은 자료형 간의 자연스러운 계층 관계를 반영할 수 있어서 유연성이 높아지고 컴파일 시에 형 검사를 하기 용이하다.

> 태그 필드가 있는 클래스를 만난다면, 리팩터링을 통해 클래스 계층으로 변환하자.
<hr/>

### 규칙 21. 전략을 표현하고 싶을 때는 함수 객체를 사용하라
프로그래밍 언어 가운데는 함수 포인터, 대리자, 람다 표현식처럼, 특정 함수를 호출할 수 있는 능력을 저장하고 전달할 수 있도록 하는 것들이 있다. 이런 기능은 보통 함수의 인자로 함수를 전달하기 위해 널리 사용되는데, 이때 인자로 전달되는 함수는 호출된 함수의 기능을 변경하는 구실을 한다.
###### 요약
함수 객체의 주된 용도는 전략 패턴을 구현하는 것이다. 자바로 이 패턴을 구현하기 위해서는 전략을 표현하는 인터페이스를 선언하고, 실행 가능 전략 클래스가 전부 해당 인터페이스를 구현하도록 해야 한다. 실행 가능 전략이 한 번만 사용되는 경우에는 보통 그 전략을 익명 클래스 객체로 구현한다. 반복적으로 사용된다면 private static 멤버 클래스로 전략을 표현한 다음, 전략 인터페이스가 자료형인 public static final 필드를 통해 외부에 공개하는 것이 바람직하다.
<hr/>

### 규칙 22. 멤버 클래스는 가능하면 static으로 선언하라
중첩 클래스는 다른 클래스 안에 정의된 클래스다. 중첩 클래스는 해당 클래스를 보조하는 용도로만 쓰여야 한다.
###### 중첩 클래스의 종류
* 정적 멤버 클래스
* 비-정적 멤버 클래스
* 익명 클래스
* 지역 클래스
> 첫 번째를 제외한 나머지는 전부 내부 클래스다.

* 바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 때는 항상 선언문 앞에 static을 붙여서 비-정적 멤버 클래스 대신 정적 멤버 클래스로 만들자.
  * static을 생략하면 모든 객체는 내부적으로 바깥 객체에 대한 참조를 유지하게 된다. 그 덕분에 시간과 공간 요구량이 늘어나며, 바깥 객체에 대한 쓰레기 수집이 힘들어진다. 비-정적 클래스 객체는 바깥 객체 없이는 생성할 수 없다는 문제도 있다.
###### 요약
중첩 클래스를 메서드 밖에서 사용할 수 있어야 하거나, 메서드 안에 놓기에 너무 길 경우에는 멤버 클래스로 정의하자. 멤버 클래스의 객체 각각이 바깥 객체에 대한 참조를 가져야 하는 경우에는 비-정적 멤버 클래스로 만들자. 그렇지 않은 경우에는 정적 멤버 클래스로 만들면 된다. 중첩 클래스가 특정한 메서드에 속해야 하고, 오직 한곳에서만 객체를 생성하며, 해당 중첩 클래스의 특성을 규정하는 자료형이 이미 있다면 익명 클래스로 만들자. 그렇지 않을 때는 지역 클래스로 만들면 된다.
