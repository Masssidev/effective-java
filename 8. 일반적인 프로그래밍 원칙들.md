# 일반적인 프로그래밍 원칙들
### 규칙 45. 지역 변수의 유효범위를 최소화하라
지역 변수의 유효범위를 최소화하면 가독성과 유지보수성이 좋아지고, 오류 발생 가능성도 줄어든다.
> 지역 변수의 유효범위를 최소화하는 가장 강력한 기법은, 처음으로 사용하는 곳에서 선언하는 것이다.

> 거의 모든 지역 변수 선언에는 초기값(initializer)이 포함되어야 한다. 변수를 적절히 초기화하기에 충분한 정보가 없다면, 그때까지는 선언을 미뤄야 한다.

> 지역 변수의 유효범위를 최소화하는 전략 중 하나는 메서드의 크기를 줄이고 특정한 기능에 집중하는 것이다.
<hr/> 

### 규칙 46. for 문보다는 for-each 문을 사용하라
for-each 문은 전통적인 for 문에 비해 명료하고 버그 발생 가능성도 적으며, 성능도 for 문에 뒤지지 않는다. 
* for-each 문을 적용할 수 없는 경우
  1. 필터링 - 컬렉션을 순회하다가 특정한 원소를 삭제할 필요가 있다면, 반복자를 명시적으로 사용해야 한다. 반복자의 remove 메서드를 호출해야 하기 때문이다.
  2. 변환 - 리스트나 배열을 순회하다가 그 원소 가운데 일부 또는 전부의 값을 변경해야 한다면, 원소의 값을 수정하기 위해서 리스트 반복자나 배열 참자가 필요하다.
  3. 병렬 순회 - 여러 컬렉션을 병렬적으로 순회해야 하고, 모든 반복자나 첨자 변수가 발맞춰 나아가도록 구현해야 한다면 반복자나 첨자 변수를 명시적으로 제어할 
  필요가 있을 것이다. 
<hr/>

### 규칙 47. 어떤 라이브러리가 있는지 파악하고, 적절히 활용하라
표준 라이브러리를 사용하면 그 라이브러리를 개발한 전문가의 지식뿐만 아니라 보다 먼저 사용한 사람들의 경험을 활용할 수 있다. 또한, 실제로 하려는 일과 큰 관련성도 
없는 문제에 대한 해결 방법을 임의로 구현하느라 시간을 낭비하지 않아도 된다. 마지막으로, 별다른 노력을 하지 않아도 그 성능이 점차로 개선된다.
> 중요한 새 릴리스가 나올 때마다 많은 기능이 새로 추가되는데, 그때마다 어떤 것들이 추가되었는지를 알아두는 것이 좋다.

> 자바 프로그래머라면 java.lang, java.util 안에 있는 내용은 잘 알고 있어야 하며, java.io의 내용도 어느 정도 알고 있어야 한다.
<hr/>

### 규칙 48. 정확한 답이 필요하다면 float와 double은 피하라
float와 double은 기본적으로 과학 또는 엔지니어링 관련 계산에 쓰일 목적으로 설계된 자료형이다. 이 자료형들은 이진 부동 소수점 연산을 수행하는데, 이것은 
넓은 범위의 값에 대해 정확도가 높은 근사치를 제공할 수 있도록 세심하게 설계된 연산이다. 하지만 정확한 결과를 제공하지는 않기 때문에 정확한 결과가 필요한 
곳에는 사용하면 안 된다. 
> float와 double은 특히 돈과 관계된 계산에는 적합하지 않다.

> 돈 계산을 할 때는 BigDecimal, int 또는 long을 사용한다는 원칙을 지켜야 한다.
<hr/>

### 규칙 49. 객체화된 기본 자료형 대신 기본 자료형을 이용하라
기본 자료형과 객체화된 기본 자료형 사이에는 세 가지 큰 차이점이 있다.
1. 기본 자료형은 값만 가지지만 객체화된 기본 자료형은 값 외에도 신원(identity)을 가진다.
2. 기본 자료형에 저장되는 값은 전부 기능적으로 완전한 값이지만, 객체화된 기본 자료형에 저장되는 값에는 그 이외에도 아무 기능도 없는 값, 즉 null이 하나 있다.
3. 기본 자료형은 시간이나 공간 요구량 측면에서 일반적으로 객체 표현형보다 효율적이다.
> 객체화된 기본 자료형에 == 연산자를 사용하는 것은 거의 항상 오류라고 봐야 한다.

> 기본 자료형과 객체화된 기본 자료형을 한 연산 안에 엮어 놓으면 객체화된 기본 자료형은 자동으로 기본 자료형으로 변환된다.
* 객체화된 기본 자료형을 사용하는 경우
1. 컬렉션의 요소, 키, 값으로 사용할 때 - 컬렉션에는 기본 자료형을 넣을 수 없으므로 객체화된 기본 자료형을 써야 한다.
2. 형인자 자료형(parameterized type)의 형인자로는 객체화된 기본 자료형을 써야 한다.
###### 요약
* 기본 자료형이 더 단순하고 빠르다.
* 자동 객체화는 번거로운 일을 줄여주긴 하지만, 객체화된 기본 자료형을 사용할 때 생길 수 있는 문제들까지 없애주진 않는다. 
* 객체화된 기본 자료형 객체 두 개를 ==로 비교한다는 것은 그 두 객체의 신원을 비교한다는 것이며, 그것은 십중팔구 원하는 것과는 거리가 멀다.
* 객체화된 기본 자료형과 기본 자료형을 한 표현식 안에 뒤섞으면 비 객체화가 자동으로 일어나며, 그 과정에서 NullPointerException이 발생할 수 있다.
* 기본 자료형 값을 객체화하는 과정에서 불필요한 객체들이 만들어지면 프로그램 성능이 저하될 수도 있다.
<hr/>

### 규칙 50. 다른 자료형이 적절하다면 문자열 사용은 피하라
데이터가 파일이나 네트워크나 키보드를 통해서 들어올 때는 보통 문자열 형태지만, 그대로 두지 말고 데이터가 숫자라면 int나 float, BigInteger 같은 수 자료형(numeric type)으로 
변환해야 한다. 예 아니오를 묻는 질문의 답이라면 boolean으로 변환해야 한다. 
> 적절한 값 자료형이 있다면 그것이 기본 자료형이건 아니면 객체 자료형이건 상관없이 해당 자료형을 사용해야 한다.
* 문자열은 값 자료형(value type)을 대신하기에는 부족하다.
* 문자열은 enum 자료형을 대신하기에는 부족하다.
* 문자열은 혼합 자료형을 대신하기엔 부족하다.
* 문자열은 권한을 표현하기엔 부족하다.
###### 요약
더 좋은 자료형이 있거나 만들 수 있을 때는 객체를 문자열로 표현하는 것은 피하라. 제대로 쓰지 못할 경우 문자열은 다른 자료형에 비해 다루기 성가시고, 유연성도 떨어지며, 
느리고, 오류 발생 가능성도 높다. 문자열이 적합하지 못한 자료형으로는 기본 자료형, enum, 혼합 자료형 등이 있다.
<hr/>

### 규칙 51. 문자열 연결 시 성능에 주의하라
n개의 문자열에 연결 연산자를 반복 적용해서 연결하는 데 드는 시간은 n^2에 비례한다. 문자열이 변경 불가능하기 때문이다. 문자열 두 개를 연결할 때, 그 두 문자열의 내용은 전부 복사된다.
> 만족스런 성능을 얻으려면 String 대신 StringBuilder를 사용해야 한다.
<hr/>

### 규칙 52. 객체를 참조할 때는 그 인터페이스를 사용하라
객체를 참조할 때는 클래스보다 인터페이스를 사용해야 한다. 만일 적당한 인터페이스 자료형이 있다면 인자나 반환값, 변수, 그리고 필드의 자료형은 클래스 대신 인터페이스로 선언해야 한다.
> 인터페이스를 자료형으로 쓰는 습관을 들이면 프로그램은 더욱 유연해진다.

> 적당한 인터페이스가 없는 경우에는 객체를 클래스로 참조하는 것이 당연한다. 필요한 기능을 제공하는 클래스 가운데 가장 일반적인 클래스를 클래스 계층 안에서 찾아서 이용해야 한다.
<hr/>

### 규칙 53. 리플렉션 대신 인터페이스를 이용하라
java.lang.reflect의 핵심 리플렉션 기능을 이용하면 메모리에 적재된 클래스의 정보를 가져오는 프로그램을 작성할 수 있다. Class 객체가 주어지면, 해당 객체가 나타내는 클래스의 생성자, 메서드, 필드 등을 나타내는 Constructor, Method, Field 객체들을 가져올 수 있는데, 이 객체들을 사용하면 클래스의 멤버 이름이나 필드 자료형, 메서드 시그너처 등의 정보들을 얻어낼 수 있다.

게다가 Constructor, Method, Field 객체를 이용하면, 연결되어 있는 실제 생성자, 메서드, 필드들을 반영적으로 조작할 수 있다.
###### 단점
* 컴파일 시점에 자료형을 검사함으로써 얻을 수 있는 이점들을 포기해야 한다. 리플렉션을 통해 존재하지 않는, 또는 접근할 수 없는 메서드를 호출하면 실행 도중에 오류가 발생할 것이다. 
* 리플렉션 기능을 이용하는 코드는 보기 싫은데다 장황하다. 영리한 코드와는 거리가 멀고, 가독성도 떨어진다.
* 성능이 낮다. 리플렉션을 통한 메서드 호출 성능은, 일반적인 메서드 호출에 비해 훨씬 낮다. 
> 일반적인 프로그램은 프로그램 실행 중에 리플렉션을 통해 객체를 이용하려 하면 안 된다.

> 리플렉션을 아주 제한적으로만 사용하면 오버헤드는 피하면서도 리플렉션의 다양한 장점을 누릴 수 있다.
###### 요약
리플렉션은 특정한 종류의 복잡한 시스템 프로그래밍에 필요한, 강력한 도구다. 하지만 단점이 많다. 컴파일 시점에는 알 수 없는 클래스를 이용하는 프로그램을 작성하고 있다면, 리플렉션을 사용하되 가능하면 객체를 만들 때만 이용하고, 객체를 참조할 때는 컴파일 시에 알고 있는 인터페이스나 상위 클래스를 이용해야 한다.
<hr/>

### 규칙 54. 네이티브 메서드는 신중하게 사용하라
자바의 네이티브 인터페이스는 C나 C++ 등의 네이티브 프로그래밍 언어로 작성된 네이티브 메서드를 호출하는 데 이용되는 기능이다. 네이티브 메서드가 수행하는 임의의 계산은 네이티브 언어로 실행되며, 자바 언어로 전달된다.
> 네이티브 메서드를 통해 성능을 개선하는 것은 좋지 않다.
네이티브 메서드에는 심각한 문제가 있다. 네이티브 언어는 안전하지 않으므로 네이티브 메서드를 이용하는 프로그램은 메모리 훼손 문제로부터 자유로울 수 없다. 게다가 네이티브 언어는 플랫폼 종속적이므로, 이식성이 낮다. 또한 네이티브 코드를 사용하는 프로그램은 디버깅하기도 훨씬 어렵다. 
<hr/>

### 규칙 55. 신중하게 최적화하라
* 맹목적인 어리석음을 비롯한 다른 어떤 이유보다도, 효율성이라는 이름으로 저질러지는 죄악이 더 많다. 
* 작은 효율성에 대해서는, 말하자면 97% 정도에 대해서는, 잊어버려라. 섣부른 최적화는 모든 악의 근원이다.
* 최적화를 할 때는 아래의 두 규칙을 따르라.
  1. 하지 마라.
  2. 아직은 하지 마라.
> 빠른 프로그램이 아닌, 좋은 프로그램을 만들려 노력해야 한다.

> 설계를 할 때는 성능을 제약할 가능성이 있는 결정들은 피해야 한다.

> API를 설계할 때 내리는 결정들이 성능에 어떤 영향을 끼칠지를 생각해야 한다.

> 좋은 성능을 내기 위해 API를 급진적으로 바꾸는 것은 좋지 않다.

> 최적화를 시도할 때마다, 전후 성능을 측정하고 비교해야 한다.
###### 요약
빠른 프로그램을 만들고자 애쓰지 말고, 좋은 프로그램을 짜기 위해 애써야 한다. 성능은 따라올 것이다. 하지만 시스템을 설계할 때, 특히 API나 통신 프로토콜, 또는 지속성 데이터 형식을 설계할 때는 성능 문제를 따져야 한다. 시스템 구현을 마쳤다면 그 성능을 측정해 봐야 한다. 충분히 빠르다면 끝난 것이다. 그렇지 않다면 프로파일링 도구의 도움을 받아서 문제가 되는 것을 알아낸 다음에 최적화하라. 처음으로 해야 할 일은 구현에 쓰인 알고리즘을 검토하는 것이다. 저수준 최적화를 아무리 해 봐야, 알고리즘을 잘못 골랐다면 성능을 만회할 수 없다. 이 프로세스를 필요한 만큼 반복하고, 최적화 단계별로 성능을 측정해야 한다.
<hr/>

### 규칙 56. 일반적으로 통용되는 작명 관습을 따르라
* 패키지 이름은 마침표를 구분점으로 사용하는 계층적 이름이어야 한다. 알파벳 소문자로 구성하고, 숫자는 거의 사용하지 않는다. 조직 바깥에서 이용될 패키지 이름은 해당 조직의 인터넷 도메인 이름으로 시작한다. 최상위 도메인 이름이 먼저 온다.
* 패키지 이름의 나머지 부분은 어떤 패키지인지 설명하는 하나 이상의 컴포넌트로 구성된다. 패키지명 컴포넌트는 짧아야 하며, 보통 여덟 문자 이하로 만들어진다. 의미가 확실한 약어를 활용하면 좋다.
* enum이나 어노테이션 자료형 이름을 비롯, 클래스나 인터페이스 이름은 하나 이상의 단어로 구성된다. 각 단어의 첫 글자는 대문자다. max나 min처럼 널리 쓰이는 약어를 제외하면, 약어 사용은 피해야 한다.
* 메서드와 필드 이름은 클래스나 인터페이스 이름과 동일한 철자 규칙을 따른다. 다만 첫 글자는 소문자로 한다.
* 상수 필드의 이름은 하나 이상의 대문자 단어로 구성되며, 단어 사이에는 밑줄 기호(언더 바)를 둔다.
* 지역 변수 이름은 멤버 이름과 같은 철자 규칙을 따르는데, 약어가 허용된다는 것만 다르다.
* 자료형 인자의 이름은 보통 하나의 대문자다. 임의 자료형인 경우엔 T, 컬렉션의 요소 자료형인 경우에는 E, 맵의 키와 값에 대해서는 각각 K와 V, 예외인 경우네는 X를 사용한다. 임의 자료형이 연속되는 경우에는 T, U, V처럼 하거나 T1, T2, T3처럼 나열한다.
###### 예제

식별자 자료형 | 예제
:--------:|:-----------:
패키지 | com.google.inject, org.joda.time.format
클래스나 인터페이스 | Timer, FutureTask, LinkedHashMap, HttpServlet
메서드나 필드 | remove, ensureCapacity, getCrc
상수 필드 | MIN_VALUE, NEGATIVE_INFINITY
지역 변수 | i, xref, houseNumber
자료형 인자 | T, E, K, V, X, T1, T2

###### 문법적 작명 관습은 더 가변적일 뿐만 아니라, 철자 관습에 비해 논쟁의 여지가 많다. 
* 패키지의 경우에는 문법적 작명 관습이라 할 만한 것이 없다. 
* enum 자료형을 비롯한 클래스에는 단수형의 명사나 명사구가 이름으로 붙는다. 
* 인터페이스도 클래스와 비슷한 작명 규칙을 따른다. able이나 ible 같은 형용사격 어미가 붙기도 한다. 
* 어노테이션 자료형은 쓰임새가 너무 다양해서 딱히 지배적이라 할 만한 규칙이 없다. 명사, 동사, 전치사, 형용사 가운데 어느 것이나 널리 쓰인다. 
* 어떤 동작을 수행하는 메서드는 일반적으로 동사나 동사구(목적어 포함)를 이름으로 갖는다.
* boolean 값을 반환하는 메서드의 이름은 보통 is, 드물게는 has로 시작하고, 그 뒤에는 명사나 명사구, 또는 형용사나 형용사구가 붙는다.
* boolean 이외의 기능이나 객체 속성을 반환하는 메서드에는 보통 명사나 명사구, 또는 get으로 시작하는 동사구를 이름으로 붙인다.
* 빈(bean) 클래스에 속한 메서드의 이름은 반드시 get으로 시작해야 한다.
* 객체의 자료형을 변환하는 메서드, 다른 자료형의 독립적 객체를 반환하는 메서드에는 보통 toType 형태의 이름을 붙인다. 
* 인자로 전달받은 객체와 다른 자료형의 뷰(view) 객체를 반환하는 메서드에는 asType 형태의 이름을 붙인다. (ex: asList)
* 호출 대상 객체와 동일한 기본 자료형 값을 반환하는 메서드에는 typeValue와 같은 형태의 이름을 붙인다. 
* 정적 팩터리 메서드에는 valueOf, of, getInstance, newInstance, getType, newType 같은 이름을 붙인다.
* 필드 이름에는 특별한 문법적 관습이 없을 뿐더러, 클래스나 인터페이스, 메서드 이름 규칙에 비하면 별로 중요하지도 않다. 잘 설계된 API에는 외부로 공개된 필드가 별로 없기 때문이다.
* boolean 형의 필드에는 보통 boolean 메서드와 같은 이름을 붙이나, 접두어 is는 생략한다.
* 다른 자료형의 필드에는 보통 명사나 명사구를 이름으로 쓴다.
* 지역 변수에도 비슷한 규칙이 적용되나, 훨씬 느슨하다.
