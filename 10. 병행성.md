# 병행성
스레드를 이용하면 여러 활동을 병렬적으로 진행할 수 있다. 병렬 프로그래밍은 단일 스레드 프로그래밍보다 어렵지만 멀티코어 프로세서에서 좋은 성능을 내야 한다는 
요구사항도 보편화되고 있기에 외면할 수 없다.
<hr/>

### 규칙 66. 변경 가능 공유 데이터에 대한 접근은 동기화하라
synchronized 키워드는 특정 메서드나 코드 블록을 한 번에 한 스레드만 사용하도록 보장한다. 
> 동기화 메커니즘을 적절히 사용하기만 하면, 모든 메서드가 항상 객체의 일관된 상태만 보도록 만들 수 있다.

동기화는 스레드가 일관성이 깨진 객체를 관측할 수 없도록 할 뿐 아니라, 동기화 메서드나 동기화 블록에 진입한 스레드가 동일한 락의 보호 아래 이루어진 모든 
변경(modification)의 영향을 관측할 수 있도록 보장한다.
> 상호 배제성뿐 아니라 스레드 간의 안정적 통신을 위해서도 동기화는 반드시 필요하다.

> 읽기 연산과 쓰기 연산에 전부 적용하지 않으면 동기화는 아무런 효과도 없다.

> 변경 가능 데이터는 한 스레드만 이용하도록 해야 한다. 이 지침을 따를 때는 이 사실을 문서로 남겨놓아야 한다.
###### 요약
변경 가능한 데이터를 공유할 때는 해당 데이터를 읽거나 쓰는 모든 스레드는 동기화를 수행해야 한다.동기화를 하지 않으면 다른 스레드가 만든 변경사항을 관측할 수 있으리라는 보장을 할 수 없다. 
변경 가능 데이터를 적절히 동기화하지 않으면 생존 오류나 안전 오류가 생긴다. 가장 디버깅하기 까다로운 오류들이다.
<hr/>

### 규칙 67. 과도한 동기화는 피하라
생존 오류나 안전 오류를 피하고 싶으면, 동기화 메서드나 블록 안에서 클라이언트에게 프로그램 제어 흐름을 넘기지 말아야 한다. 다시 말해서, 동기화가 적용된 영역 안에서는 
재정의 가능 메서드나 클라이언트가 제공한 함수 객체 메서드를 호출하지 말아야 한다는 것이다. 동기화 영역이 존재하는 클래스 관점에서 보면, 이런 메서드는 불가해 메서드다. 
무슨 일을 하는지 알 수도 없고, 제어할 수도 없다. 불가해 메서드가 어떤 일을 하느냐에 따라, 동기화 영역 안에서 호출하게 되면 예외나 교착상태, 데이터 훼손이 발생할 수 있다.
> 동기화 영역 안에서 수행되는 작업의 양을 가능한 한 줄여야 한다.

자바가 등장한 이후로 동기화 비용이 급격히 낮아지긴 했지만, 과도한 동기화를 피하는 것은 지금 어느 때보다도 중요하다. 멀티코어 세상에서 동기화의 진짜 비용은 
락을 거느라 소비되는 CPU 시간이 아니다. 병렬성을 활용할 기회를 읽는다는 것, 그리고 모든 코어가 동일한 메모리 뷰를 보도록 하기 위해 필요한 지연시간이 더 큰 비용이다. 
동기화가 지나치면 VM이 코드를 제한적으로만 최적화하여 실행할 수 있다는 것도 문제다.
###### 요약
데드락과 데이터 훼손 문제를 피하려면 동기화 영역 안에서 불가해 메서드는 호출하지 말아야 한다. 동기화 영역 안에서 하는 작업의 양을 제한하라는 것이다. 변경 가능 클래스를 
설계할 때는, 내부적으로 동기화를 처리해야 하는지 살펴봐야 한다. 멀티코어 시대에 접어들면서, 지나친 동기화를 피하도록 설계하는 것은 더욱 중요해지고 있다. 타당한 이유가 있을 때만 내부적으로 
동기화하고, 어떤 결정을 내렸는지를 문서에 명확하게 밝혀야 한다.
<hr/>

### 규칙 68. 스레드보다는 실행자와 태스크를 이용하라
릴리스 1.5부터 자바 플랫폼에는 java.util.concurrent가 추가되었다. 이 패키지에는 실행자 프레임워크라는 것이 들어 있는데, 유연성이 높은 인터페이스 기반 
태스크 실행 프레임워크다.

실행자 서비스로 할 수 있는 일은 많다. 특정 태스크가 종료되기를 기다릴 수도 있고, 임의의 태스크들이 종료되기를 기다릴 수도 있고, 실행자 서비스가 자연스럽게 종료되기를 기다릴 수도 있으며, 
태스크가 끝날 때마다 그 결과를 차례로 가져올 수도 있다. 이 외에도 많다.

큐의 작업을 처리하는 스레드를 여러 개 만들고 싶을 때는 스레드 풀이라 부르는 실행자 서비스를 생성하는 정적 팩터리 메서드를 이용하면 된다. 스레드 풀에 담기는 스레드의 숫자는 고정시켜 놓을 수도 있고, 
가벼적으로 변하도록 설정할 수도 있다. java.util.concurrent.Executors 클래스에는 필요한 실행자 대부분을 생성할 수 있도록 하는 정적 팩터리 메서드들이 들어 있다. 하지만 일반적이지 않은 무언가가 
필요할 때는 ThreadPoolExecutor 클래스를 직접 이용할 수도 있다. 이 클래스를 이용하면 스레드 풀의 동작을 거의 모든 측면에서 세밀하게 제어할 수 있다.
> 작업 큐를 손수 구현하는 것은 삼가야 할 뿐 아니라, 일반적으로는 스레드를 직접 이용하는 것도 피하는 것이 좋다.

Thread는 작업의 단위였을 뿐 아니라 작업을 실행하는 메커니즘이기도 했다. 하지만 이제 Thread는 더 이상 중요하지 않다. 작업과 실행 메커니즘이 분리된 것이다. 중요한 것은 
작업의 단위이며, 태스크(task)라 부른다. 태스크에는 두 가지 종류가 있다. Runnable과, Callable이다. (Callable은 Runnable과 비슷하지만 값을 반환한다는 차이가 있다.) 태스크를 실행하는 
일반 메커니즘은 실행자 서비스다. 태스크와 실행자 서비스를 분리해서 생각하게 되면 실행 정책을 더욱 유연하게 정할 수 있게 된다. 핵심은, 컬렉션 프레임워크가 
데이터를 모으는 일을 처리하는 것과 마찬가지로, 실행자 프레임워크는 태스크를 실행하는 부분을 담당한다는 것이다.

실행자 프레임워크에는 java.util.Timer를 대신할 ScheduledThreadPoolExecotor도 정의되어 있다. 타이머보다 사용하기 편리할 뿐 아니라, 유연성도 훨씬 높다. 
타이머는 하나의 스레드만 사용해서 태스크를 실행하기 때문에 실행시간이 긴 태스크가 있는 경우에는 타이밍 정확도가 떨어지게 된다. 게다가 타이머가 이용하는 오직 하나의 
스레드 안에서 발생한 예외가 제대로 처리되지 않을 경우 타이머는 더 이상 동작하지 않는다. 반면 ScheduledThreadPoolExecutor는 여러 스레드를 이용할 뿐 아니라, 태스크 안에서 
무점검 예외가 발생한 상황도 복구한다.
<hr/>

### 규칙 69. wait나 notify대신 병행성 유틸리티를 이용하라
릴리스 1.5부터 자바 플랫폼에는 고수준 병행성 유틸리티들이 포함되어, 예전에는 wait와 notify를 사용해 구현해야만 했던 일들을 대신한다. wait와 notify를 
정확하게 사용하는 것이 어렵기 때문에, 이 고수준 유틸리티들을 반드시 이용해야 한다.

java.util.concurrent에 포함된 이 유틸리티들은 실행자 프레임워크, 병행 컬렉션, 그리고 동기자(synchronizer)의 세 가지 범주로 나눌 수 있다.

병행 컬렉션은 List, Queue, Map 등의 표준 컬렉션 인터페이스에 대한 고성능 병행 컬렉션 구현을 제공한다. 이 컬렉션들은 병행성을 높이기 위해 동기화를 내부적으로 처리한다. 따라서 컬렉션 외부에서 
병행성을 처리하는 것은 불가능하다. 락을 걸어봐야 아무 효과가 없을 뿐 아니라 프로그램만 느려진다.
> 따라서 클라이언트는 병행 컬렉션에 대한 메서드 호출을 원자적으로 작성할 수 없다. 그래서 컬렉션 인터페이스 가운데 일부는 상태 종속 변경 연산으로 확장되었는데, 
이는 몇 가지 기본 연산들을 하나의 원자적 연산으로 묶은 것이다.

동기자는 스레드들이 서로를 기다릴 수 있도록 하여, 상호 협력이 가능하게 한다. 가장 널리 쓰이는 동기자로는 CountDownLatch와 Semaphore가 있다. 사용 빈도는 낮지만 
CyclicBarrier나 Exchanger 같은 것도 쓰인다.
###### 요약
wait나 notify를 사용해 프로그램을 짜는 것은 마치 "병행성 어셈블리 언어"를 사용해 코딩하는 것과 같다. java.til.concurrent가 제공하는 고수준 언어에 비교했을 때 말이다.
새로 만드는 프로그램에 wait나 notify를 사용할 이유는 거의 없다.
<hr/>

### 규칙 70. 스레드 안전성에 대해 문서로 남겨라
