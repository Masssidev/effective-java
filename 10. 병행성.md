# 병행성
스레드를 이용하면 여러 활동을 병렬적으로 진행할 수 있다. 병렬 프로그래밍은 단일 스레드 프로그래밍보다 어렵지만 멀티코어 프로세서에서 좋은 성능을 내야 한다는 
요구사항도 보편화되고 있기에 외면할 수 없다.
<hr/>

### 규칙 66. 변경 가능 공유 데이터에 대한 접근은 동기화하라
synchronized 키워드는 특정 메서드나 코드 블록을 한 번에 한 스레드만 사용하도록 보장한다. 
> 동기화 메커니즘을 적절히 사용하기만 하면, 모든 메서드가 항상 객체의 일관된 상태만 보도록 만들 수 있다.

동기화는 스레드가 일관성이 깨진 객체를 관측할 수 없도록 할 뿐 아니라, 동기화 메서드나 동기화 블록에 진입한 스레드가 동일한 락의 보호 아래 이루어진 모든 
변경(modification)의 영향을 관측할 수 있도록 보장한다.
> 상호 배제성뿐 아니라 스레드 간의 안정적 통신을 위해서도 동기화는 반드시 필요하다.

> 읽기 연산과 쓰기 연산에 전부 적용하지 않으면 동기화는 아무런 효과도 없다.

> 변경 가능 데이터는 한 스레드만 이용하도록 해야 한다. 이 지침을 따를 때는 이 사실을 문서로 남겨놓아야 한다.
###### 요약
변경 가능한 데이터를 공유할 때는 해당 데이터를 읽거나 쓰는 모든 스레드는 동기화를 수행해야 한다.동기화를 하지 않으면 다른 스레드가 만든 변경사항을 관측할 수 있으리라는 보장을 할 수 없다. 
변경 가능 데이터를 적절히 동기화하지 않으면 생존 오류나 안전 오류가 생긴다. 가장 디버깅하기 까다로운 오류들이다.
<hr/>

### 규칙 67. 과도한 동기화는 피하라
생존 오류나 안전 오류를 피하고 싶으면, 동기화 메서드나 블록 안에서 클라이언트에게 프로그램 제어 흐름을 넘기지 말아야 한다. 다시 말해서, 동기화가 적용된 영역 안에서는 
재정의 가능 메서드나 클라이언트가 제공한 함수 객체 메서드를 호출하지 말아야 한다는 것이다. 동기화 영역이 존재하는 클래스 관점에서 보면, 이런 메서드는 불가해 메서드다. 
무슨 일을 하는지 알 수도 없고, 제어할 수도 없다. 불가해 메서드가 어떤 일을 하느냐에 따라, 동기화 영역 안에서 호출하게 되면 예외나 교착상태, 데이터 훼손이 발생할 수 있다.
> 동기화 영역 안에서 수행되는 작업의 양을 가능한 한 줄여야 한다.

자바가 등장한 이후로 동기화 비용이 급격히 낮아지긴 했지만, 과도한 동기화를 피하는 것은 지금 어느 때보다도 중요하다. 멀티코어 세상에서 동기화의 진짜 비용은 
락을 거느라 소비되는 CPU 시간이 아니다. 병렬성을 활용할 기회를 읽는다는 것, 그리고 모든 코어가 동일한 메모리 뷰를 보도록 하기 위해 필요한 지연시간이 더 큰 비용이다. 
동기화가 지나치면 VM이 코드를 제한적으로만 최적화하여 실행할 수 있다는 것도 문제다.
###### 요약
데드락과 데이터 훼손 문제를 피하려면 동기화 영역 안에서 불가해 메서드는 호출하지 말아야 한다. 동기화 영역 안에서 하는 작업의 양을 제한하라는 것이다. 변경 가능 클래스를 
설계할 때는, 내부적으로 동기화를 처리해야 하는지 살펴봐야 한다. 멀티코어 시대에 접어들면서, 지나친 동기화를 피하도록 설계하는 것은 더욱 중요해지고 있다. 타당한 이유가 있을 때만 내부적으로 
동기화하고, 어떤 결정을 내렸는지를 문서에 명확하게 밝혀야 한다.
<hr/>

### 규칙 68. 스레드보다는 실행자와 태스크를 이용하라
릴리스 1.5부터 자바 플랫폼에는 java.util.concurrent가 추가되었다. 이 패키지에는 실행자 프레임워크라는 것이 들어 있는데, 유연성이 높은 인터페이스 기반 
태스크 실행 프레임워크다.

실행자 서비스로 할 수 있는 일은 많다. 특정 태스크가 종료되기를 기다릴 수도 있고, 임의의 태스크들이 종료되기를 기다릴 수도 있고, 실행자 서비스가 자연스럽게 종료되기를 기다릴 수도 있으며, 
태스크가 끝날 때마다 그 결과를 차례로 가져올 수도 있다. 이 외에도 많다.

큐의 작업을 처리하는 스레드를 여러 개 만들고 싶을 때는 스레드 풀이라 부르는 실행자 서비스를 생성하는 정적 팩터리 메서드를 이용하면 된다. 스레드 풀에 담기는 스레드의 숫자는 고정시켜 놓을 수도 있고, 
가벼적으로 변하도록 설정할 수도 있다. java.util.concurrent.Executors 클래스에는 필요한 실행자 대부분을 생성할 수 있도록 하는 정적 팩터리 메서드들이 들어 있다. 하지만 일반적이지 않은 무언가가 
필요할 때는 ThreadPoolExecutor 클래스를 직접 이용할 수도 있다. 이 클래스를 이용하면 스레드 풀의 동작을 거의 모든 측면에서 세밀하게 제어할 수 있다.
> 작업 큐를 손수 구현하는 것은 삼가야 할 뿐 아니라, 일반적으로는 스레드를 직접 이용하는 것도 피하는 것이 좋다.

Thread는 작업의 단위였을 뿐 아니라 작업을 실행하는 메커니즘이기도 했다. 하지만 이제 Thread는 더 이상 중요하지 않다. 작업과 실행 메커니즘이 분리된 것이다. 중요한 것은 
작업의 단위이며, 태스크(task)라 부른다. 태스크에는 두 가지 종류가 있다. Runnable과, Callable이다. (Callable은 Runnable과 비슷하지만 값을 반환한다는 차이가 있다.) 태스크를 실행하는 
일반 메커니즘은 실행자 서비스다. 태스크와 실행자 서비스를 분리해서 생각하게 되면 실행 정책을 더욱 유연하게 정할 수 있게 된다. 핵심은, 컬렉션 프레임워크가 
데이터를 모으는 일을 처리하는 것과 마찬가지로, 실행자 프레임워크는 태스크를 실행하는 부분을 담당한다는 것이다.

실행자 프레임워크에는 java.util.Timer를 대신할 ScheduledThreadPoolExecotor도 정의되어 있다. 타이머보다 사용하기 편리할 뿐 아니라, 유연성도 훨씬 높다. 
타이머는 하나의 스레드만 사용해서 태스크를 실행하기 때문에 실행시간이 긴 태스크가 있는 경우에는 타이밍 정확도가 떨어지게 된다. 게다가 타이머가 이용하는 오직 하나의 
스레드 안에서 발생한 예외가 제대로 처리되지 않을 경우 타이머는 더 이상 동작하지 않는다. 반면 ScheduledThreadPoolExecutor는 여러 스레드를 이용할 뿐 아니라, 태스크 안에서 
무점검 예외가 발생한 상황도 복구한다.
<hr/>

### 규칙 69. wait나 notify대신 병행성 유틸리티를 이용하라
릴리스 1.5부터 자바 플랫폼에는 고수준 병행성 유틸리티들이 포함되어, 예전에는 wait와 notify를 사용해 구현해야만 했던 일들을 대신한다. wait와 notify를 
정확하게 사용하는 것이 어렵기 때문에, 이 고수준 유틸리티들을 반드시 이용해야 한다.

java.util.concurrent에 포함된 이 유틸리티들은 실행자 프레임워크, 병행 컬렉션, 그리고 동기자(synchronizer)의 세 가지 범주로 나눌 수 있다.

병행 컬렉션은 List, Queue, Map 등의 표준 컬렉션 인터페이스에 대한 고성능 병행 컬렉션 구현을 제공한다. 이 컬렉션들은 병행성을 높이기 위해 동기화를 내부적으로 처리한다. 따라서 컬렉션 외부에서 
병행성을 처리하는 것은 불가능하다. 락을 걸어봐야 아무 효과가 없을 뿐 아니라 프로그램만 느려진다.
> 따라서 클라이언트는 병행 컬렉션에 대한 메서드 호출을 원자적으로 작성할 수 없다. 그래서 컬렉션 인터페이스 가운데 일부는 상태 종속 변경 연산으로 확장되었는데, 
이는 몇 가지 기본 연산들을 하나의 원자적 연산으로 묶은 것이다.

동기자는 스레드들이 서로를 기다릴 수 있도록 하여, 상호 협력이 가능하게 한다. 가장 널리 쓰이는 동기자로는 CountDownLatch와 Semaphore가 있다. 사용 빈도는 낮지만 
CyclicBarrier나 Exchanger 같은 것도 쓰인다.
###### 요약
wait나 notify를 사용해 프로그램을 짜는 것은 마치 "병행성 어셈블리 언어"를 사용해 코딩하는 것과 같다. java.til.concurrent가 제공하는 고수준 언어에 비교했을 때 말이다.
새로 만드는 프로그램에 wait나 notify를 사용할 이유는 거의 없다.
<hr/>

### 규칙 70. 스레드 안전성에 대해 문서로 남겨라
병렬적으로 사용해도 안전한 클래스가 되려면, 어떤 수준의 스레드 안전성을 제공하는 클래스인지 문서에 명확하게 남겨야 한다.
###### 스레드 안전성 수준
* 변경 불가능(immutable) - 이 클래스로 만든 객체들은 상수다. 따라서 외부적인 동기화 메커니즘 없이도 병렬적 이용이 가능하다. String, Long, BigInteger등이 예다.
* 무조건적 스레드 안전성 - 이 클래스의 객체들은 변경이 가능하지만 적절한 내부 동기화 메커니즘을 갖추고 있어서 외부적으로 동기화 메커니즘을 적용하지 않아도 병렬적으로 상ㅇ할 수 있다. Random, ConcurrentHashMap 같은 클래스가 예다.
* 조건부 스레드 안전성 - 무조건적 스레드 안전성과 거의 같은 수준이나 몇몇 스레드는 외부적 동기화가 없이는 병렬적으로 사용할 수 없다. Collections.synchronized 계열 메서드가 반환하는 포장(wraper) 객체가 그 예다. 이런 객체의 반복자(iterator)는 외부적 동기화 없이는 병렬적으로 이용할 수 없다.
* 스레드 안전성 없음 - 이 클래스의 객체들은 변경 가능하다. 해당 객체들을 병렬적으로 사용하려면 클라이언트는 메서드를 호출하는 부분을 클라이언트가 선택한 외부적 동기화 수단으로 감싸야 한다. ArrayList나 HashMap 같은 일반 용도의 컬렉션 구현체들이 그 예다.
* 다중 스레드에 적대적 - 이런 클래스의 객체는 설사 메서드를 호출하는 모든 부분을 외부적 동기화 수단으로 감싸더라도 안전하지 않다. 이런 클래스가 되는 것은 보통, 동기화 없이 정적 데이터를 변경하기 때문이다. 누구도 이런 클래스를 고의로 만들지는 않는다. 그저 병행성을 생각하지 못하고 구현했기 때문이다. 다행히도, 자바 라이브러리에는 이런 클래스가 별로 없다. System.runFinalizersOnExit 메서드는 스레드에 적대적인 대표적인 메서드로, 지금은 폐기(deprecated)되었다.

클래스의 스레드 안전성에 대한 설명은 일반적으로 클래스의 문서화 주석에 들어가지만, 특별한 스레드 안전성 속성을 갖는 메서드는 그 속성을 자기 문서화 주석에 설명해야 한다.
###### 요약
모든 클래스는 자신의 스레드 안전성 수준을 문서로 분명히 밝혀야 한다. synchronized 키워드는 이런 문서에서는 아무런 역할도 하지 못한다. 조건부 스레드 안전성을 제공하는 클래스는 어떤 순서로 메서드를 호출할 때 외부적 동기화가 필요한지 문서에 밝혀야 하고, 그때 어떤 락을 획득하게 되는지도 밝혀야 한다. 무조건적 스레드 안전성을 제공하는 클래스를 구현하는 중이라면 메서드를 synchronized로 선언하는 대신 private 락 객체를 이용하면 어떨지 따져봐야 한다. 이런 락 객체를 이용하면 클라이언트나 하위 클래스가 동기화에 개입하는 것을 막을 수 있고, 다음번 릴리스에는 좀 더 복잡한 병행성 제어 전략도 쉽게 채택할 수 있게 된다.
<hr/>

### 규칙 71. 초기화 지연은 신중하게 하라
초기화 지연(lazy initialization)은 필드 초기화를 실제로 그 값이 쓰일 때까지 미루는 것이다. 값을 사용하는 곳이 없다면 필드는 결코 초기화되지 않을 것이다. 

초기화 지연이 적용된 필드 가운데 실제로 초기화되어야 하는 필드의 비율, 초기화 비용, 그리고 필드의 실제 이용 빈도에 따라 실제 성능은 떨어질 수 있다.
> 대부분의 경우, 지연된 초기화를 하느니 일반 초기화를 하는 편이 낫다.

> 초기화 순환성 문제를 해소하기 위해서 초기화를 지연시키는 경우에는 동기화된 접근자를 사용하면 된다.
###### 요약
대부분의 필드 초기화는 지연시키지 않아야 한다. 더 좋은 성능을 내거나, 해로운 초기화 순환성을 제거할 목적으로 필드 초기화를 지연시키고자 할 때는, 적절한 초기화 지연 기술을 이용하면 된다. 객체 필드에는 이중 검사 숙어를 적용하고, 정적 필드에는 초기화 지연 담당 클래스를 사용하면 된다. 여러 번 초기화되어도 상관 없는 필드라면 단일 검사도 고려해볼 만하다.
<hr/>

### 규칙 72. 스레드 스케줄러에 의존하지 마라
* 정확성을 보장하거나 성능을 높이기 위해 스레드 스케줄러에 의존하는 프로그램은 이식성이 떨이진다. 안정적이고, 즉각 반응하며 이식성이 좋은 프로그램을 만드는 가장 좋은 방법은, 실행 가능 스레드의 평균적 수가 프로세서 수보다 많아지지 않도록 하는 것이다.
* 실행 가능 스레드의 수를 일정 수준으로 낮추는 기법의 핵심은 각 스레드가 필요한 일을 하고 나서 다음에 할 일을 기다리게 만드는 것이다. 스레드는 필요한 일을 하고 있지 않을 때는 실행 중이어서는 안 된다.
* 스레드는 바쁘게 대기해서는 안 된다. 즉, 무언가 일어나길 기다리면서 공유 객체를 계속 검사해서는 안된다. 바쁘게 대기하는 스레드를 이용하는 프로그램은 스케줄러 변화에 취약하다.
* 스레드 우선순위는 자바 플랫폼에서 가장 이식성이 낮은 부분 가운데 하나다.
###### 요약
프로그램의 정확성을 스레드 스케줄러에 의존하지 말아야 한다. 이런 프로그램은 안정적이지도 않고 이식성이 보장되지도 않는다. 마찬가지로, Thread.yield나 스레드 우선순위에 의존하지도 말아야 한다. 이런 것들은 스케줄러 입장에서는 단순한 힌트일 뿐이다. 스레드 우선순위는 이미 잘 돌고 있는 프로그램의 품질을 개선하는 보조적 수단으로 활용할 수는 있으나, 겨우 돌아갈 듯 말 듯 하는 프로그램을 "고치는"데 이용해서는 안 된다.
<hr/>

### 규칙 73. 스레드 그룹은 피하라
스레드 시스템이 제공하는 기본적인 추상화 단위 가운데는 스레드, 락, 모니터 이외에도 스레드 그룹이라는 것이 있다. 스레드 그룹은 원래 애플릿을 격리시켜 보안 문제를 피하고자 고안된 것이었으나, 그 목적을 달성하진 못했다. 그 중요성도 점차로 희미해져, 자바 보안 모델을 표준화한 결과물에는 아예 언급도 되지 못했다. 
###### 스레드 그룹의 기능
* 특정한 Thread 기본 연산을 여러 스레드에 동시에 적용할 수 있도록 한다.
> 문제는 이런 기본 연산 가운데 상당수는 폐기(deprecated)되었고, 나머지도 별로 쓰이지 않는다는 것이다.

ThreadGroup API의 스레드 안전성은 취약하다. 스레드 그룹의 하위 그룹을 나열하는 API도 마찬가지다.
> 스레드 그룹은 이제 폐기된 추상화 단위다.
###### 요약
스레드 그룹에는 쓸만한 기능이 별로 없으며, 그나마 쓸만하다 싶은 기능에는 결함이 있다. 스레드 그룹은 그다지 성공적이지 못한 실험이었다고 봐야 하며, 무시해야 한다. 스레드를 논리적인 그룹으로 나누는 클래스를 만들어야 한다면, 스레드 풀 실행자(thread pool executor)를 이용하는 것이 바람직하다. 
