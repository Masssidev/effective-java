# 객체의 생성과 삭제
### 규칙 1. 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라
클래스를 통해 객체를 만드는 일반적인 방법은 public으로 선언된 생성자를 이용하는 것이다. 그러나 모든 프로그래머가 반드시 알고 있어야 하는 방법이 하나 
더 있다. 클래스에 public으로 선언된 **정적 팩터리 메서드**를 추가하는 것이다.
* 정적 팩터리 메서드의 장점
  * 첫 번째 장점은, 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다.
  * 두 번째 장점은, 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요는 없다.
  * 세 번째 장점은, 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
  * 네 번째 장점은, 형인자 자료형 객체를 만들 때 편하다
* 정적 팩터리 메서드의 단점
  * public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다.
  * 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다.
* 보통 정적 팩터리 메서드의 이름으로는 다음과 같은 것들을 사용한다.
  * valueOf
  * of
  * getInstance
  * newInstance
  * getType
  * newType
> 정적 팩터리 메서드와 public 생성자는 용도가 서로 다르며, 그 차이와 장단점을 이해하는 것이 중요하다. 정적 팩터리 메서드가 효과적인 경우가 많으니, 
정적 팩터리 메서드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가야 한다.
<hr/>

### 규칙 2. 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라
정적 팩터리나 생성자는 같은 문제를 갖고 있다. 선택적 인자가 많은 상황에 잘 적응하지 못한다는 것이다. 보통 프로그래머들은 이런 상황에 **점층적 생성자 패턴**을 
적용한다. 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 추가하는 식으로, 생성자들을 쌓아 올리듯 추가하는 것이다.
> 점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기가 어려워지고, 무엇보다 읽기 어려운 코드가 된다.

생성자에 전달되는 인자 수가 많을 때 적용 가능한 두 번째 대안은 **자바빈**패턴이다. 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정 메서드들을 호출하여 필수 
필드뿐 아니라 선택적 필드의 값들까지 채우는 것이다.
> 자바빈 패턴에는 심각한 단점이 있다. 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성이 일시적으로 깨질 수 있다. 또한, 자바빈 패턴으로는 변경 불가능 클래스를 만들 수 없다.

Builder 패턴은 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에(또는 정적 팩터리 메서드에) 전부 전달하여 빌더 객체를 만든다. 그런 
다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다. 그리고 마지막으로 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만드는 것이다.
 빌더 클래스는 만드는 객체 클래스의 멤버 클래스로 정의한다.
> 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유용하다.
<hr/>

### 규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라
싱글턴은 객체를 하나만 만들 수 있는 클래스다. 싱글턴은 보통 유일할 수밖에 없는 시스템 컴포넌트를 나타낸다. 
* JDK 1.5 이전에는 싱글턴을 구현하는 방법이 두 가지였다. 두 방법 다 생성자는 private로 선언하고, 싱글턴 객체는 정적 멤버를 통해 이용한다.
  * 첫 번째 방법의 경우, 정적 멤버는 final로 선언한다.
  * 두 번째 방법은 public으로 선언된 정적 팩터리 메소드를 이용한다.
* JDK 1.5부터는 싱글턴을 구현할 때 새로운 방법을 사용할 수 있다. 원소가 하나뿐인 enum 자료형을 정의하는 것이다.
> 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법이다.
<hr/>

### 규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라
객체를 만들 수 없도록 하려고 클래스를 abstract로 선언해 봤자 소용없다. 하위 클래스를 정의하는 순간 객체 생성이 가능해지기 때문이다.
> 기본 생성자는 클래스에 생성자가 없을 때 만들어지니까, private 생성자를 클래스에 넣어서 객체 생성을 방지하자는 것이다.

> 또한, 이렇게 하면 하위 클래스도 만들 수 없다. 모든 생성자는 상위 클래스의 생성자를 명시적으로든 아니면 묵시적으로든 호출할 수 있어야 하는데, 호출 가능한 생성자가 상위 클래스에 없기 때문이다.
<hr/>

### 규칙 5. 불필요한 객체는 만들지 마라
기능적으로 동일한 객체는 필요할 때마다 만드는 것보다 재사용하는 편이 낫다. 객체를 재사용하는 프로그램은 더 빠르고 더 우아하다. 생성자와 정적 팩터리 메서드를 함께 제공하는 변경 불가능 클래스의 경우, 생성자 대신 정적 팩터리 메서드를 이용하면 불필요한 객체 생성을 피할 수 있을 때가 많다. 생성자는 호출할 때만다 새 객체를 만들지만, 정적 팩터리 메서드는 그럴 필요도 없고 실제로 그러지도 않을 것이다.

JDK 1.5부터는 쓸데없이 객체를 만들 새로운 방법이 더 생겼다. **자동 객체화: autoboxing**라는 것인데, 프로그래머들이 자바의 기본 자료형과 그 객체 효현형을 섞어 사용할 수 있도록 해 준다. 둘 간의 변환은 자동으로 이뤄진다. 
> 객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않도록 유의하라.
<hr/>

### 규칙 6. 유효기간이 지난 객체 참조는 폐기하라
만기 참조란, 다시 이용되지 않을 참조를 말한다. 만기 참조를 제거하지 않는다면 메모리 릭이 발생한다. 쓸 일없는 객체 참조는 무조건 null로 만들어야 한다. 만기 참조를 null로 만들면 나중에 실수로 그 참조를 사용하더라도 NullPointerException이 발생하기 때문에, 프로그램은 오동작하는 대신 바로 종료된다는 장점도 있다. 프로그래밍 오류는 최대한 빨리 알아내는 것이 좋다.
> 객체 참조를 null 처리하는 것은 규범이라기보단 예외적인 조치가 되어야 한다.

* 일반적으로, 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 릭이 발생하지 않도록 주의해야 한다.
* 더 이상 사용되지 않는 원소 안에 있는 객체 참조는 반드시 null로 바꿔 주어야 한다.
* 캐시도 메모리 누수가 흔히 발생하는 장소다. 객체 참조를 캐시 안에 넣어 놓고 잊어버리는 일이 많기 때문이다.
* 메모리 누수가 흔히 발견되는 또 한 곳은 리스너 등의 역호출자(callback)다. 역 호출자 등록 기능을 제공하는 API를 사용하는 클라이언트가 역 호출자를 명시적으로 제거하지 않을 경우, 적절한 조치를 취하기 전까지 메모리는 점유된 상태로 남아있게 된다.
<hr/>

### 규칙 7. 종료자 사용을 피하라
종료자(finalizer)는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다. 종료자의 한 가지 단점은, 즉시 실행되리라는 보장이 전혀 없다는 것이다. 어떤 객체에 대한 모든 참조가 사라지고 나서 종료자가 실행되기까지는 긴 시간이 걸릴 수도 있다.
> 따라서 긴급한 작업을 종료자 안에서 처리하면 안 된다.

* 지속성이 보장되어야 하는 중요 상태 정보는 종료자로 갱신하면 안 된다.
* 종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.
> 명시적인 종료 메서드를 하나 정의하고, 더 이상 필요하지 않는 객체라면 클라이언트가 해당 메서드를 호출하도록 해야 한다.

명시적 종료 메서드는 보통 try-finally 문과 함께 쓰인다. 객체 종료를 보장하기 위해서다. 
> 자원 반황에 대한 최종적 안전장치를 구현하거나, 그다지 중요하지 않은 네이티브 자원을 종료시키려는 것이 아니라면 종료자는 사용하지 말라.

> 굳이 종료자를 사용해야 하는 드문 상황에 처했따면 super.finalize 호출을 잊지 말라.

> 자원 반환 안전망을 구현하는 경우에는 종료자가 호출될 때마다 클라이언트 코드가 잘못 작성되었을 알리는 메시지를 로그로 남기자.

> 하위 클래스 정의가 가능한 public 클래스에 종료자를 추가해야 하는 상황이라면, 하위 클래스에서 실수로 super.finalize 호출을 잊어도 종료 작업이 진행될 수 있도록 종료 보호자 패턴을 도입하면 좋을지 고려하라.
