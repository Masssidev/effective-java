# 객체의 생성과 삭제
### 규칙 1. 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라
클래스를 통해 객체를 만드는 일반적인 방법은 public으로 선언된 생성자를 이용하는 것이다. 그러나 모든 프로그래머가 반드시 알고 있어야 하는 방법이 하나 
더 있다. 클래스에 public으로 선언된 **정적 팩터리 메서드**를 추가하는 것이다.
* 정적 팩터리 메서드의 장점
  * 첫 번째 장점은, 생성자와는 달리 정적 팩터리 메서드에는 이름이 있다.
  * 두 번째 장점은, 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요는 없다.
  * 세 번째 장점은, 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
  * 네 번째 장점은, 형인자 자료형 객체를 만들 때 편하다
* 정적 팩터리 메서드의 단점
  * public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다.
  * 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다.
* 보통 정적 팩터리 메서드의 이름으로는 다음과 같은 것들을 사용한다.
  * valueOf
  * of
  * getInstance
  * newInstance
  * getType
  * newType
> 정적 팩터리 메서드와 public 생성자는 용도가 서로 다르며, 그 차이와 장단점을 이해하는 것이 중요하다. 정적 팩터리 메서드가 효과적인 경우가 많으니, 
정적 팩터리 메서드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가야 한다.
<hr/>

### 규칙 2. 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라
정적 팩터리나 생성자는 같은 문제를 갖고 있다. 선택적 인자가 많은 상황에 잘 적응하지 못한다는 것이다. 보통 프로그래머들은 이런 상황에 **점층적 생성자 패턴**을 
적용한다. 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 추가하는 식으로, 생성자들을 쌓아 올리듯 추가하는 것이다.
> 점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기가 어려워지고, 무엇보다 읽기 어려운 코드가 된다.

생성자에 전달되는 인자 수가 많을 때 적용 가능한 두 번째 대안은 **자바빈**패턴이다. 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정 메서드들을 호출하여 필수 
필드뿐 아니라 선택적 필드의 값들까지 채우는 것이다.
> 자바빈 패턴에는 심각한 단점이 있다. 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로, 객체 일관성이 일시적으로 깨질 수 있다. 또한, 자바빈 패턴으로는 변경 불가능 클래스를 만들 수 없다.

Builder 패턴은 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에(또는 정적 팩터리 메서드에) 전부 전달하여 빌더 객체를 만든다. 그런 
다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다. 그리고 마지막으로 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만드는 것이다.
 빌더 클래스는 만드는 객체 클래스의 멤버 클래스로 정의한다.
> 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유용하다.
<hr/>

### 규칙 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라
싱글턴은 객체를 하나만 만들 수 있는 클래스다. 싱글턴은 보통 유일할 수밖에 없는 시스템 컴포넌트를 나타낸다. 
* JDK 1.5 이전에는 싱글턴을 구현하는 방법이 두 가지였다. 두 방법 다 생성자는 private로 선언하고, 싱글턴 객체는 정적 멤버를 통해 이용한다.
  * 첫 번째 방법의 경우, 정적 멤버는 final로 선언한다.
  * 두 번째 방법은 public으로 선언된 정적 팩터리 메소드를 이용한다.
* JDK 1.5부터는 싱글턴을 구현할 때 새로운 방법을 사용할 수 있다. 원소가 하나뿐인 enum 자료형을 정의하는 것이다.
> 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법이다.
<hr/>

### 규칙 4. 객체 생성을 막을 때는 private 생성자를 사용하라
객체를 만들 수 없도록 하려고 클래스를 abstract로 선언해 봤자 소용없다. 하위 클래스를 정의하는 순간 객체 생성이 가능해지기 때문이다.
> 기본 생성자는 클래스에 생성자가 없을 때 만들어지니까, private 생성자를 클래스에 넣어서 객체 생성을 방지하자는 것이다.

> 또한, 이렇게 하면 하위 클래스도 만들 수 없다. 모든 생성자는 상위 클래스의 생성자를 명시적으로든 아니면 묵시적으로든 호출할 수 있어야 하는데, 호출 가능한 생성자가 상위 클래스에 없기 때문이다.
<hr/>

### 불필요한 객체는 만들지 마라
