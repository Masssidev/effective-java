# 제네릭
제네릭이 도입되기 전, 프로그래머는 컬렉션에서 객체를 읽어낼 때마다 형변환을 해줘야 했다. 하지만 제네릭을 사용하면 컬렉션에 넣는 객체의 자료형이 무엇인지 컴파일러에게 알릴 수 있다.
형변환 코드는 컴파일러가 알아서 넣어 줄 것이고, 잘못된 자료형의 객체를 컬렉션에 넣으려는 시도는 컴파일 과정에서 차단된다. 그 덕에 프로그램은 더 안전하고 명료해지지만, 
프로그램이 복잡해진다.
<hr/>

### 규칙 23. 새 코드에는 무인자 제네릭 자료형을 사용하지 마라
* 선언부에 형인자가 포함된 클래스나 인터페이스는 제네릭 클래스나 인터페이스라고 부른다. 제네릭 클래스와 인터페이스는 제네릭 자료형이라 부른다.
* 각 제네릭 자료형은 형인자 자료형 집합을 정의한다. 이 집합은 이름 뒤에 ```<>```기호로 감싼 실 형인자 목록이 붙은 클래스나 인터페이스 들로 구성되는데, 이 실 인자들은 제네릭 자료형의 형식 형인자 각각에 대응된다.
* 각 제네릭 자료형은 새로운 무인자 자료형(raw type)을 정의하는데, 무인자 자료형은 실 형인자 없이 사용되는 제네릭 자료형이다.
> 무인자 자료형을 쓰면 형 안정성이 사라지고, 제네릭의 장점 중 하나인 표현력 측면에서 손해를 보게 된다.

> 이미 구현되어 있는 코드들과의 호환성을 위해 무인자 자료형을 지원하게 된 것이다.

버전 1.5부터 자바는 비한정적 와일드카드 자료형이라는 좀 더 안전한 대안을 제공한다. 제네릭 자료형을 쓰고 싶으나 실제 형 인자가 무엇인지는 모르거나 신경 쓰고 싶지 않을 때는 인자로 '?'를 쓰면 된다. 비한정적 와이드카드 자료형과 무인자 자료형의 차이는 무인자 자료형 컬렉션에는 아무 객체나 넣을 수 있어서, 컬렉션의 자료형 불변식이 쉽게 깨진다. 그러나 비한정적 와일드카드 자료형에는 null 이외의 어떤 원소도 넣을 수 없다. 뭔가 넣으려고 하면 컴파일 과정에서 오류 메시지가 뜬다.
<hr/>

### 규칙 24. 무점검 경고를 제거하라
###### 제네릭으로 프로그램하다 보면 나타날 수 있는 컴파일러 경고 메시지
* 무점검 형변환 경고
* 무점검 메소드 호출 경고
* 무점검 제네릭 배열 생성 경고
* 무점검 변환 경고
> 모든 무점검 경고는, 가능하다면 없애야 한다.

> 제거할 수 없는 경고 메시지는 형 안정성이 확실할 때만 @SupressWarnings("unchecked") 어노테이션을 사용해 억제해야 한다. @SupressWarnings("unchecked") 어노테이션을 사용할 때마다, 왜 형 안정성을 위반하지 않는지 밝히는 주석을 붙여야 한다.
<hr/>

### 규칙 25. 배열 대신 리스트를 써라
배열과 제네릭 자료형의 차이점
1. 배열은 공변 자료형이다. Sub가 Super의 하위 자료형이라면 Sub[]도 Super[]의 하위 자료형이다. 반면 제네릭은 불변 자료형이다. ```List<Type1>```은 ```List<Type2>```의 상위 자료형이나 하위 자료형이 될 수 없다.
2. 배열은 실체화 되는 자료형이다. 배열의 각 원소의 자료형은 실행시간(runtime)에 결정된다. 반면 제네릭은 자료형에 관계된 조건들은 컴파일 시점에만 적용되고, 그 각 원소의 자료형 정보는 프로그램이 실행될 때는 삭제된다.
> 제네릭 자료형이나 형인자 자료형, 또는 형인자의 배열을 생성하는 것은 문법적으로 허용되지 않는다. 컴파일하려고 하면 제네릭 배열 생성이라는 오류가 발생한다.

> 프로그램이 실행될 때 해당 자료형을 표현하는 정보의 양이 컴파일 시점에 필요한 정보의 양보다 적은 자료형이 실체화 불가능 자료형이다.

> 배열은 컴파일 시간에 형 안전성을 보장하지 못하며, 제네릭은 그 반대다 
<hr/>

### 규칙 26. 가능하면 제네릭 자료형으로 만들 것
클래스를 제네릭화하는 법
1. 선언부에 형인자(type parameter)를 추가한다.
2. Object를 자료형으로 사용하는 부분들을 전부 찾아서, 형인자 E로 대체하고 컴파일해 본다.
  * 오류나 경고메시지를 만난다. 이를 해결한다.
###### 요약
제네릭 자료형은 클라이언트가 형변환을 해야만 사용할 수 있는 자료형보다 안전할 뿐 아니라 사용하기도 쉽다. 새로운 자료형을 설계할 때는 형변환 없이도 사용할 수 있도록 해야 한다. 그러려면 제네릭 자료형으로 만들어야 할 때가 많을 것이다.
<hr/>

### 규칙 27. 가능하면 제네릭 메서드로 만들 것
static 유틸리티 메서드는 특히 제네릭화하기 좋은 후보다.
> 형인자를 선언하는 형인자 목록(type parameter list)은 메서드의 수정자와 반환값 자료형 사이에 둔다.

제네릭 메서드의 특징 하나는, 제네릭 생성자를 호출할 때는 명시적으로 주어야 했던 형인자를 전달할 필요가 없다는 것이다. 컴파일러는 메서드에 전해진 인자의 자료형을 보고 형인자의 값을 알아낸다. 이 과정을 **자료형 유추: type inference**라 한다.
###### 요약
제네릭 자료형과 마찬가지로 제네릭 메서드는 클라이언트가 직접 입력 값과 반환값의 자료형을 형변환해야 하는 메서드보다 사용하기 쉽고 형 안전성도 높다. 자료형을 만들 때처럼, 새로운 메서드를 고안할 때는 형변환 없이도 사용할 수 있을지 보아야 한다. 
<hr/>

### 규칙 28. 한정적 와일드카드를 써서 API 유연성을 높여라
유연성을 최대화하려면, 객체 생산자나 소비자 구실을 하는 메서드 인자의 자료형은 와일드카드 자료형으로 해야 한다. 만일 메서드 인자가 생산자인 동시에 소비자라면 와일드카드 자료형은 쓸모가 없다. 자료형이 정확하게 일치해야 하는데, 그러려면 와일드카드를 빼면 된다.
```
PECS (Produce - Extends, Consumer - Super)
```
> 인자가 T 생산자라면 ```<? extends T>```라고 하고, T 소비자라면 ```<? super T>```라고 하면 된다.

> 반환값에는 와일드카드 자료형을 쓰면 안 된다.

> 형인자가 메서드 선언에 단 한군데 나타난다면 해당 인자를 와일드카드로 바꿔야 한다.
###### 요약
API에는 와일드카드 자료형을 사용하라는 것이다. 까다롭긴 하지만, API의 유연성은 높아질 것이다. 널리 쓰일 라이브러리를 작성하고 있다면, 와일드카드 자료형을 적절히 쓰는 것은 필수다. 생산자는 extends이고 소비자는 super(PECS)다. 모든 Comparable과 Comparator는 소비자다.
<hr/>

### 규칙 29. 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라
컬렉션 API를 통해 확인할 수 있는 제네릭의 일반 용법에 따르면, 컨테이너별로 형인자 개수는 고정되어 있다. 그런데 컨테이너 대신 키를 제네릭으로 만들면 그런 제약이 없는 형 안전 다형성 컨테이너를 만들 수 있다. 그런 컨테이너는 Class 객체를 키로 쓰는데, 그런 Class 객체를 자료형 토큰이라 부른다. 키 자료형을 직접 구현하는 것도 가능하다. 예를 들어, 데이터베이스 레코드를 표현하는 DatabaseRow 클래스의 경우(컨테이너), 제네릭 자료형 ```Column<T>```를 키로 사용할 수 있다.
