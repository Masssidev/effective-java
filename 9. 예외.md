# 예외
잘만 활용하면 예외는 프로그램의 가독성, 안정성, 유지보수성을 모두 향상시킬 수 있다. 그러나 제대로 쓰지 않으면 반대 효과도 낸다.
<hr/>

### 규칙 57. 예외는 예외적 상황에만 사용하라
* 예외는 예외적인 상황에만 사용해야 한다.
* 평상시 제어 흐름에 이용해서는 안 된다.
* 클라이언트에게 평상시 제어 흐름의 일부로 예외를 사용하도록 강요하는 API도 만들면 안 된다.
<hr/>

### 규칙 58. 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라
자바는 세 가지 종류의 'throwable'을 제공한다.
1. 점검지정 예외(checked exception)
2. 실행시점 예외(runtime exception)
3. 오류(error)

점검지정 예외를 사용할 것인지 아니면 무점검 예외(unchecked exception)를 사용할 것인지에 대한 가장 기본적인 규칙은, 호출자 측에서 복구할 것으로 여겨지는 
상황에 대해서는 점검지정 예외를 이용해야 한다는 것이다. 점검지정 예외를 던지는 메서드를 호출한 클라이언트는 해당 예외를 catch 절 안에서 처리하든지, 아니면 
계속 밖으로 던져지도록 놔두든지 해야 한다.
> API 사용자에게 점검지정 예외를 준다는 것은, 그 상태를 복구할 권한을 준다는 뜻이다. 사용자는 그 권한을 무시할 수 있다. 하지만 일반적으로는 무시하면 곤란하다.

무점검 'throwable'에는 실행시점 예외와 오류 두 가지가 있으며, 동작 방식은 같다. 둘 다 catch로 처리할 필요가 없으며, 일반적으로는 처리해서도 안 된다. 
프로그램이 무점검 예외나 오류를 던진다는 것은 복구가 불가능한 상황에 직면했다는 뜻으로, 더 진행해 봐야 득보다 실이 더 크다는 뜻이다. 이런 throwable을 catch하지 
않는 스레드는 적절한 오류 메시지를 내면서 중단된다.

> 프로그래밍 오류를 표현할 때는 실행시점 예외를 사용하라.<br/>

보통 오류(error)는 JVM이 자원부족이나 불변식 위반 등, 더 이상 프로그램을 실행할 수 없는 상태에 도달했음을 알리기 위해 사용한다. 더 이상 프로그램을 실행할 수 없는 
상태에 도달했음을 알리기 위해 사용한다. 이 관습은 거의 보편적으로 받아들여지고 있어서, Error의 하위 클래스는 새로 만들지 않는 것이 최선이다. 따라서 사용자 정의 
무점검 throwable은 RuntimeException의 하위 클래스로 만들어야 한다.
###### 요약
* 복구 가능한 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류를 나타내고 싶을 때는 실행시점 예외를 사용하라.
* 점검지정 예외는 일반적으로 복구가 가능한 상태를 나타내기 때문에, 호출자 측에서 상태를 복구하는 데 이용할 정보를 제공하는 메서드를 갖춰 놓는 것이 아주 중요하다.
<hr/>

### 규칙 59. 불필요한 점검지정 예외 사용은 피하라
점검지정 예외는 코드를 반환하는 것과는 달리, 프로그래머로 하여금 예외적인 상황을 처리하도록 강제함으로써 안정성을 높인다. 너무 남발하면 사용하기 불편한 API가 
될수도 있다는 뜻이기도 하다. 하나 이상의 점검지정 예외를 던지는 메서드를 호출할 때는 예외를 받아 처리하는 catch 블록을 하나 이상 만들든가, 아니면 예외를 다시 밖으로 던진다고 선언하고는 외부로 전파되도록 
내버려둬야 한다. 프로그래머 입장에서는 간단치 않은 일이다.
> API를 제대로 이용해도 예외 상황이 벌어지는 것을 막을 수 없을 때, 그리고 API 사용자가 예외 상황에 대한 조치를 취할 수 있을 때 말고는 무점검 예외를 이용하는 것이 좋다.
<hr/>

### 규칙 60. 표준 예외를 사용하라
프로그래밍 전문가는 코드 재사용을 위해 노력할 뿐 아니라, 보통 높은 수준으로 코드를 재사용한다. 코드를 재사용하면 좋다는 일반 규칙은 예외에도 어김없이 적용된다.
자바 플랫폼 라이브러리에는 대부분의 API가 필요로 하는 기본적인 무점검 예외들이 갖추어져 있다.

> 이미 있는 예외들을 재사용하면 배우기 쉽고 사용하기 편리한 API를 만들 수 있다. 또, 가독성이 높아진다. 마지막으로 예외 클래스 개수를 줄이면 프로그램의 메모리 
요구량이 줄어들고, 클래스를 로딩하는 시간도 줄어든다.
###### 널리 재사용되는 예외

예외 | 용례
:-----:|:-----:
IllegalArgumentException | null이 아닌 인자의 값이 잘못되었을 때
IllegalStateException | 객체 상태가 메서드 호출을 처리하기에 적절치 않을 때
NullPointerException | null 값을 받으면 안 되는 인자에 null이 전달되었을 때
IndexOutOfBoundsException | 인자로 주어진 첨자가 허용 범위를 벗어났을 때
ConcurrentModificationException | 병렬적 사용이 금지된 객체에 대한 병렬 접근이 탐지되었을 때
UnsupportedOperationException | 객체가 해당 메서드를 지원하지 않을 때
<hr/>

### 규칙 61. 추상화 수준에 맞는 예외를 던져라
상위 계층에서는 하위 계층에서 발생하는 예외를 반드시 받아서 상위 계층 추상화 수준에 맞는 예외로 바꿔서 던져야 한다. 이를 **예외 변환**이라고 한다.

예외 연결은 예외 변환의 특별한 사례다. 하위 계층에서 발생한 예제 정보가 상위 계층 예외를 발생시킨 문제를 디버깅하는 데 유용할 때 사용한다. 하위 계층 예외(원인: cause)는 상위 계층 예외로 전달되는데, 상위 계층 예외에 있는 접근자 메서드(Throwable.getCause)를 호출하면 해당 정보를 꺼낼수 있다.
> 대부분의 표준 예외들은 예외 연결 지원 생성자를 구비하고 있다. 생성자가 없는 예외에는 Throwable.initCause 메서드를 호출하면 하위 계층 예외를 연결할 수 있다.

> 예외 연결 기능을 사용하면 프로그램 안에서 예외의 원인에 접근할 수 있을 뿐 아니라(getCause를 이용해서), 최초에 발생한 예외의 스택 추적 정보(stack trace)를 상위 계층 예외에 통합할 수 있게 된다.
###### 요약
하위 계층에서 발생하는 예외를 막거나 처리할 수 없다면, 상위 계층에 보여주면 곤란한 예외는 예외 변환을 통해 처리해야 한다. 예외 연결 패턴을 활용하면 적절한 상위 계층 예외를 보여주면서도 하위 계층에서 실제로 발생한 문제까지 확인할 수 있으므로 오류를 분석하기 좋다.
<hr/>

### 규칙 62. 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라
* 메서드를 올바르게 사용하려면, 메서드에서 던져지는 예외에 대한 설명이 문서에 있어야 한다. 따라서 예외 문서화는 아주 중요하다.
* 점검지정 예외는 독립적으로 선언하고, 해당 예외가 발생하는 상황은 Javadoc @throws 태그를 사용해서 정확하게 밝혀야 한다.
* 특히 인터페이스 메서드에 대한 문서는, 각 메서드에서 발생할 수 있는 무점검 예외들을 밝혀야 한다.
> Javadoc @throws 태그를 사용해서 메서드에서 발생 가능한 모든 무점검 예외에 대한 문서를 남겨야 한다. 하지만 메서드 선언부의 throws 뒤에 무점검 예외를 나열 하진 말아야 한다. 그래야 API 사용자가 무엇이 점검지정 예외이고 무엇이 무점검 예외인지 알 수 있다.

> 동일한 예외를 던지는 메서드가 많다면, 메서드마다 문서를 만드는 대신, 해당 예외에 대한 문서는 클래스의 문서화 주석에 남겨도 된다.
###### 요약
메서드가 던질 가능성이 있는 모든 예외를 문서로 남겨야 한다. 점검지정 예외뿐만 아니라, 무점검 예외에도 문서를 만들어야 한다. 일반 메서드뿐 아니라, abstract 메서드에도 문서를 만들어야 한다. 점검지정 예외는 메서드의 throws 절에 나열하고, 무점검 예외는 throws 절에는 적지 않는다. 메서드가 던질 가능성이 있는 예외에 대해 문서를 남기지 않으면, 다른 사람이 효과적으로 사용할 수 있는 클래스나 인터페이스는 만들기 힘들거나, 만들 수 없다.
<hr/>

### 규칙 63. 어떤 오류인지를 드러내는 정보를 상세한 메시지에 담으라
무점검 예외 때문에 프로그램이 죽으면, 시스템은 자동적으로 해당 예외의 스택 추적 정보(stack trace)를 출력한다. 이 정보는 해당 예외 객체의 toString 메서드가 예외 정보를 문자열로 변환한 결과다.
> toString 메서드가 반환하는 문자열에 오류 원인에 관계된 정보를 최대한 많이 담는 것이 아주 중요하다. 예외의 상세 메시지에는 원인 분석에 이용될 오류 정보가 포착되어 있어야 한다.

> 오류 정보를 포착해 내기 위해서는, 오류의 상세 메시지에 "예외에 관계된" 모든 인자와 필드의 값을 포함시켜야 한다.

스택 추적 정보는 원래 소스 파일과 함께 분석하는 것이다. 그 안에는 보통 예외가 발생한 지점의 파일 이름과 행 번호가 담길 뿐 아니라, 스택 상의 모든 메서드가 호출된 지점의 파일 이름과 행 번호도 담긴다. 어떤 오류인지 길게 떠드는 것은 일반적으로 불필요하다. 소스 코드를 읽으면 필요한 정보를 얻을 수 있다.

예외의 상세 메시지를 사용자 레벨 오류 메시지와 혼동해서는 안 된다. 예외에 대한 상세 메시지는 프로그래머나 서비스 담당자가 오류 원인을 분석하기 위한 것이다. 따라서 가독성보다는 내용이 훨씬 중요하다.

오류를 적절히 포착하는 정보를 상세 메시지에 담는 방법은 상세한 정보를 요구하는 생성자를 만들거나, 예외 객체에 오류 포착 정보를 제공하는 접근자 메서드를 두는 방법이 있다.
<hr/>

### 규칙 64. 실패 원자성 달성을 위해 노력하라
메서드 호출이 정상적으로 처리되지 못한 객체의 상태는, 메서드 호출 전 상태와 동일해야 한다. 이 속성을 만족하는 메서드는 실패 원자성을 갖추었다고 한다.
* 실패 원자성을 달성하는 방법
  * 변경 불가능 객체로 설계한다. 변경 불가능한 객체의 경우, 실패 원자성은 덤이다. 메서드 호출이 실패하면 새로운 객체가 만들어지지 못할 수는 있겠지만 기존 객체의 일관성이 깨지진 않는다. 일단 객체가 만들어지고 나면, 그 상태를 변경할 수 없기 때문이다.
  * 실패할 가능성이 있는 코드를 전부 객체 상태를 바꾸는 코드 앞에 배치한다.
  * 연산 수행 도중에 발생하는 오류를 가로채는 복구 코드를 작성한다. 이 복구 코드는 연산이 시작되기 이전 상태로 객체를 되돌린다.
  * 객체의 임시 복사본상에서 필요한 연산을 수행하고, 연산이 끝난 다음에 임시 복사본의 내용으로 객체 상태를 바꾼다.
> 메서드 명세에 포함된 예외가 발생하더라도 객체 상태는 메서드 호출 이전과 동일하게 유지되어야 한다. 이 규칙을 지키지 못할 경우에는 객체 상태가 어떻게 변하는지를 API 문서에 명확하게 서술해야 한다. 
<hr/>

### 규칙 65. 예외를 무시하지 마라
빈 catch 블록은 예외를 선언한 목적, 예외적 상황을 반드시 처리하도록 강제한다는 목적에 배치된다. 적어도 catch 블록 안에은 예외를 무시해도 괜찮은 이유라도 주석으로 남겨 두어야 한다.
> 점검지정 예외와 무점검 예외에 똑같이 적용된다.

예측 가능한 예외적 상황을 나타내는 예외건, 아니면 프로그래밍 오류를 나타내는 예외건 간에, 빈 catch 블록으로 예외를 무시하는 프로그램은 오류가 생겨도 조용히 실행을 계속한다. 그러다 어느 순간, 오류와는 아무 상관도 없는 지점에서 불시에 죽어버린다. 예외를 적절히 처리하면 오류로 프로그램이 죽는 일은 피할 수 있다. 게다가 예외가 바깥쪽으로 나가도록 그저 놓아두기만 해도, 적어도 프로그램이 오류가 발생한 즉시 종료되도록 만들 수 있다. 나중에 디버깅하는 데 써먹을 정보는 유지하면서.

