# 메서드
### 규칙 38. 인자의 유효성을 검사하라
대부분의 메서드와 생성자는 인자로 사용할 수 있는 값을 제한한다. 제한 들은 반드시 문서로 남겨야 할 뿐 아니라 메서드 시작 부분에서 검사해야 한다. 
> 오류(error)는 가급적 빨리 탐지해야 한다는 일반 원칙의 특수한 경우다. 이런 검사를 생략하면 오류를 탐지하기 어려워질 뿐 아니라, 설사 탐지하더라도 
발생 지점을 파악하기가 곤란해진다.
###### 요약
메서드나 생성자를 구현할 때는 받을 수 있는 인자에 제한이 있는지 따져봐야 한다. 그리고 제한이 있다면 그 사실을 문서에 남기고, 메서드 앞부분에서 검사하도록 해야 한다. 
<hr/>

### 규칙 39. 필요하다면 방어적 복사본을 만들라
자바를 사용하기가 편한 것은, 안전한 언어이기 때문이다. 그러나 안전한 언어를 쓴다 해도, 클래스의 클라이언트가 불변식을 망가뜨리기 위해 최선을 다할 것이라는 가정하에, 방어적으로 프로그래밍해야 한다.
> 인자의 유효성을 검사하기 전에 방어적 복사본을 만들고 유효성 검사는 복사본에 대해서 시행한다.

> 또한, 방어적 복사본을 만들 때는 clone을 사용하지 않고 접근자를 통한 공격을 막기 위해서 변경 가능 내부 필드에 대한 방어적 복사본을 반환하도록 접근자를 수정한다.
###### 요약
클라이언트로부터 구했거나 클라이언트에게 반환되는 변경 가능 컴포넌트가 있는 경우, 해당 클래스는 그 컴포넌트를 반드시 방어적으로 복사해야 한다. 복사 오버헤드가 
너무 크고 클래스 사용자가 그 내부 컴포넌트를 부적절하게 변경하지 않는다는 보장이 있을 때는, 방어적 복사를 하는 대신 클라이언트 측에서 해당 컴포넌트를 변경해서는 
안 된다는 사실만 문서에 명시하고 넘어갈 수도 있다.
<hr/>

### 규칙 40. 메서드 시그너처는 신중하게 설계하라
* 메서드 이름은 신중하게 고르라. 
* 편의 메서드를 제공하는 데 너무 열 올리지 마라.
* 인자 리스트를 길게 만들지 마라.
  * 여러 메서드로 나눈다.
  * 도움 클래스를 만들어 인자들을 그룹별로 나눈다.
  * 앞 두 방법을 결합한 것으로, 빌더 패턴(builder pattern)을 고쳐서 객체 생성 대신 메서드 호출에 적용한다.
* 인자의 자료형으로는 클래스보다 인터페이스가 좋다.
* 인자 자료형으로 boolean을 쓰는 것보다는, 원소가 2개인 enum 자료형을 쓰는 것이 낫다.
<hr/>

### 규칙 41. 오버로딩할 때는 주의하라
* 오버로딩된 메서드 중 어떤 것이 호출될지는 컴파일 시점에 결정된다.
* 오버로딩된 메서드는 정적으로 선택되지만, 재정의된 메서드는 동적으로 선택된다.
> 오버로딩을 사용할 때는 혼란스럽지 않게 사용할 수 있도록 주의해야 한다.

혼란을 피하는 안전하고 보수적인 전략은, 같은 수의 인자를 갖는 두 개의 오버로딩 메서드를 API에 포함시키지 않는 것이다.
###### 요약
메서드를 오버로딩할 수 있다고 해서 반드시 그래야 하는 것은 아니다. 인자 개수가 같은 오버로딩 메서드를 추가하는 것은 일반적으로 피해야 한다. 하지만 특히 생성자에 대해서라면, 형변환만 추가하면 같은 인자 집합으로 여러 오버로딩 메서드를 호출할 수 있는 상황은 피하는 것이 좋다. 그럴 수 없을 때는, 새로운 인터페이스를 구현하도록 기존 클래스를 개선해야 하는 경우가 그 예인데, 같은 인자를 넘겨 호출했을 때 모든 오버로딩 메서드가 똑같이 동작하도록 해야 한다. 
<hr/>

### 규칙 42. varags는 신중히 사용하라
자바 1.5부터는 공식적으로는 가변 인자 메서드라고 부르는 varargs 메서드가 추가되었다. 이 메서드는 지정된 자료형의 인자를 0개 이상 받을 수 있다.

동작 원리는 우선, 클라이언트에서 전달한 인자 수에 맞는 배열이 자동 생성되고, 모든 인자가 해당 배열에 대입된다. 그리고 마지막으로 해당 배열이 메서드에 인자로 전달된다.
> varargs는 정말로 임의 개수의 인자를 처리할 수 있는 메서드를 만들어야 할 때만 사용하라.

성능이 중요한 환경이라면 varargs 사용에 더욱 신중해야 한다. varargs 메서드를 호출할 때마다 배열이 만들어지고 초기화되기 때문이다. 
<hr/>

### 규칙 43. null 대신 빈 배열이나 컬렉션을 반환하라
프로파일링 결과로 해당 메서드가 성능 저하의 주범이라는 것이 밝혀지지 않은 한, 그런 수준까지 성능 걱정을 하는 것은 바람직하지 않다. 또, 길이가 0인 배열은 변경이 불가능(immutable)하므로 아무 제약 없이 재사용할 수 있다.
> 따라서, null 대신에 빈 컬렉션을 반환해야 한다.
<hr/>

### 규칙 44. 모든 API 요소에 문서화 주석을 달라
사용할 수 있는 API가 되려면 문서가 있어야 한다. 보통 API 문서는 수작업으로 만들기 때문에 실제 코드와 일치시키려면 잡일이 좀 필요하다. 그런데 자바에는 Javadoc이라는 유틸리티가 포함되어 있어서, API 문서 작업을 쉽게 할 수 있다. Javadoc은 문서화 주석(documentation comment, 또는 doc comment)이라고 부르는 좀 특별한 주석을 통해서, 소스 코드로부터 API 문서를 자동 생성한다.

문서화 주석에 익숙하지 않다면 배워야 한다. 문서화 주석 문법은 자바 언어의 일부는 아니지만, 모든 프로그래머가 알아야 하는 실질적인 표준 API다.
> 좋은 API 문서를 만들려면 API에 포함된 모든 클래스, 인터페이스, 생성자, 메서드, 그리고 필드 선언에 문서화 주석을 달아야 한다. 직렬화가 가능한 클래스라면 직렬화 형식도 밝혀야 한다.

* 메서드에 대한 문서화 주석은 메서드와 클라이언트 사이의 규약을 간명하게 설명해야 한다. 상속을 위해 설계된 메서드가 아니라면 메서드가 무엇을 하는지를 설명해야지 메서드가 어떻게 그 일을 하는지를 설명해서는 안 된다. 
* 아울러 문서화 주석에는 해당 메서드의 모든 선행조건과 후행조건을 나열해야 한다. 선행조건은 클라이언트가 메서드를 호출하려면 반드시 참(true)이 되어야 하는 조건들이다. 후행조건은 메서드 실행이 성공적으로 끝난 다음에 만족되어야 하는 조건들이다.
* 보통 선행조건은 무점검 예외(unchecked exception)에 대한 @throws 태그를 통해 암묵적으로 기술한다. 관계된 인자의 @param 태그를 통해 명시할 수도 있다.
* 선행조건과 후행조건 외에도, 메서드는 부작용에 대해서도 문서화 해야 한다. 부작용은, 후행조건을 만족하기 위해 필요한 것이 아닌, 시스템의 관측 가능한 상태 변화를 일컫는다. 예를 들어 어떤 메서드가 후면 스레드(background thread)를 실행한다면 문서에는 그 사실이 명시되어야 한다. 
* 클래스나 메서드의 스레드 안전성에 대해서도 문서에 남겨야 한다.
* 메서드의 규약을 완벽하게 기술하려면 문서화 주석에는 인자마다 @param 태그를 달아야 하고, 반환값 자료형이 void가 아니라면 @return 태그도 달아야 하고, 무점검/점검 여부에 상관없이 모든 예외에는 @throws 태그도 붙여야 한다.
* 관습적으로, @param 태그나 @return 태그 다음에는 인자나 반환값을 설명하는 명사구가 와야 한다.
* @throws 태그 다음에는 어떤 조건에서 예외가 발생하는지를 설명하는 if 절이 온다. 명사구 대신 산술 표현식이 쓰일 때도 있다.
* 관습상 @param, @return, @throws 태그 다음에 오는 구나 절에는 마침표를 찍지 않는다.

릴리스 1.5부터 포함된 제네릭, enum 그리고 어노테이션의 세 가지 기능에 대해서는 문서화 주석을 만들 때 특별히 주의해야 한다.
> 제네릭 자료형이나 메서드에 주석을 달 때는 모든 자료형 인자들을 설명해야 한다.
* enum 자료형에 주석을 달 때는 자료형이나 public 메서드뿐 아니라 상수 각각에도 주석을 달아 주어야 한다.
* 어노테이션 자료형에 주석을 달 때는 자료형뿐 아니라 모든 멤버에도 주석을 달아야 한다. 멤버에는 마치 필드인 것처럼 명사구 주석을 달아야 하낟. 자료형 요약문에는 동사구를 써서, 언제 이 자료형을 어노테이션으로 붙여야 하는지 설명해야 한다.
###### 요약
문서화 주석은 API 문서를 만드는 가장 효과적인 방법이다. 공개 API 요소라면 필수적으로 겸비해야 하는 부분으로 봐야 한다. 표준적으로 쓰이는 관습을 따르도록 해야 하며, 임의의 HTML 태그를 주석에 넣을 수 있고, HTML 메타문자는 반드시 이스케이프 처리해야 한다.
