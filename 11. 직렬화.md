# 직렬화
객체를 바이트 스트림으로 인코딩하는것을 직렬화라고 하고, 그 반대는 역직렬화라고 한다. 직렬화된 객체의 인코딩은 한 VM에서 다른 VM으로 전송 가능하고, 
나중에 역직렬화하기 위해 디스크에 저장할 수도 있다. 직렬화는 원격지 컴퓨터와 통신하기 위한 표준적 객체 인코딩을 제공하며, 자바빈 컴포넌트 아키텍처의 표준적 
지속성 데이터 형식도 제공한다.
<hr/>

### 규칙 74. Serializable 인터페이스를 구현할 때는 신중하라
* Serializable 구현과 관련된 가장 큰 문제는 일단 클래스를 릴리스하고 나면 클래스 구현을 유연하게 바꾸기 어려워진다는 것이다. 
* 두 번째 문제는, 버그나 보안 취약점이 발생할 가능성이 높아진다.
* 세 번째 문제는, 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다.

> * 상속을 염두에 두고 설계하는 클래스는 Serializable을 구현하지 않는 것이 바람직하다. 또한 인터페이스는 가급적 Serializable을 상속하지 말아야 한다.
> * 내부 클래스는 Serializable을 구현하면 안 된다. 내부 클래스의 기본 직렬화 형식은 정의될 수 없다.
###### 요약
잠깐 쓰고 버릴 클래스가 아니라면, Serializable을 구현한다는 것은 심각하게 받아들여야 하는 약속이며 신중해야 한다. 상속을 고려하여 설계하는 클래스라면 더욱 
조심해야 한다. 이런 클래스를 설계할 때, 완전히 Serializable을 구현하고 싶지는 않지만 그렇다고 하위 클래스의 Serializable 구현을 금하고 싶지도 않다면, 
무인자 생성자를 제공하는 것이 방법이다. 그런 클래스의 하위 클래스는 Serializable을 구현할지 말지 알아서 선택할 수 있다. 
<hr/>

### 규칙 75. 사용자 지정 직렬화 형식을 사용하면 좋을지 따져 보라
어떤 직렬화 형식이 적절할지 따져보지도 않고 기본 직렬화 형식을 그대로 받아들이면 안 된다. 기본 직렬화 형식을 받아들일 때는 그 인코딩이 유연성, 성능, 그리고 
정확성 관점에서 적절하다는 판단이 서야 한다.
> 기본 직렬화 형식은 그 객체의 물리적 표현이 논리적 내용과 동일할 때만 적절하다. 
###### 객체의 물리적 표현 형태가 논리적 내용과 많이 다를 경우 기본 직렬화 형식을 그대로 받아들이면 생기는 문제
* 공개 API가 현재 내부 표현 형태에 영원히 종속된다. 
* 너무 많은 공간을 차지하는 문제가 생길 수 있다.
* 너무 많은 시간을 소비하는 문제가 생길 수 있다.
* 스택 오버플로문제가 생길 수 있다.
> 기본 직렬화 형식 사용 여부에 상관없이, 객체를 직렬화 할 때는 객체의 상태 전부를 읽는 메서드에 적용할 동기화 수단을 반드시 적용해야 한다.

> 어떤 직렬화 형식을 이용하건, 직렬화 가능 클래스를 구현할 때는 직렬 버전 UID(serial version UID)를 명시적으로 선언해야 한다. 그러면 직렬 버전 UID 때문에 
생길 수 있는 잠재적 호환성 문제가 사라진다. 성능이 조금 개선되는 효과도 있다.
###### 요약
직렬화 가능한 클래스를 만들기로 했다면, 직렬화 형식에 대해서도 심각하게 고민해야 한다. 기본 직렬화 형식은 그 형태가 객체의 논리적 상태에 부합할 때만 이용해야 한다. 
그렇지 않으면 객체의 논리적 상태를 적절히 표현하는 사용자 정의 직렬화 형식을 만드는 것이 좋다. 외부로 공개되는 메서드를 설계하는 데 많은 시간을 쓰는 
것처럼, 직렬화 형식을 설계할 때도 그만한 시간을 써야 한다. 일단 공개된 메서드는 향후 버전에서 제거할 수 없듯이, 직렬화 형식에 포함시킨 필드는 나중에 제거할 수 없다. 
직렬화 호환성을 보장하기 위해서다. 직렬화 형식을 잘못 선택하면, 클래스의 복잡성과 성능 측면에 돌이킬 수 없는 악영향을 끼치게 된다.
<hr/>

### 규칙 76. readObject 메서드는 방어적으로 구현하라


