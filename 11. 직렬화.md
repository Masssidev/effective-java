# 직렬화
객체를 바이트 스트림으로 인코딩하는것을 직렬화라고 하고, 그 반대는 역직렬화라고 한다. 직렬화된 객체의 인코딩은 한 VM에서 다른 VM으로 전송 가능하고, 
나중에 역직렬화하기 위해 디스크에 저장할 수도 있다. 직렬화는 원격지 컴퓨터와 통신하기 위한 표준적 객체 인코딩을 제공하며, 자바빈 컴포넌트 아키텍처의 표준적 
지속성 데이터 형식도 제공한다.
<hr/>

### 규칙 74. Serializable 인터페이스를 구현할 때는 신중하라
* Serializable 구현과 관련된 가장 큰 문제는 일단 클래스를 릴리스하고 나면 클래스 구현을 유연하게 바꾸기 어려워진다는 것이다. 
* 두 번째 문제는, 버그나 보안 취약점이 발생할 가능성이 높아진다.
* 세 번째 문제는, 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다.

> * 상속을 염두에 두고 설계하는 클래스는 Serializable을 구현하지 않는 것이 바람직하다. 또한 인터페이스는 가급적 Serializable을 상속하지 말아야 한다.
> * 내부 클래스는 Serializable을 구현하면 안 된다. 내부 클래스의 기본 직렬화 형식은 정의될 수 없다.
###### 요약
잠깐 쓰고 버릴 클래스가 아니라면, Serializable을 구현한다는 것은 심각하게 받아들여야 하는 약속이며 신중해야 한다. 상속을 고려하여 설계하는 클래스라면 더욱 
조심해야 한다. 이런 클래스를 설계할 때, 완전히 Serializable을 구현하고 싶지는 않지만 그렇다고 하위 클래스의 Serializable 구현을 금하고 싶지도 않다면, 
무인자 생성자를 제공하는 것이 방법이다. 그런 클래스의 하위 클래스는 Serializable을 구현할지 말지 알아서 선택할 수 있다. 
<hr/>

### 규칙 75. 사용자 지정 직렬화 형식을 사용하면 좋을지 따져 보라
어떤 직렬화 형식이 적절할지 따져보지도 않고 기본 직렬화 형식을 그대로 받아들이면 안 된다. 기본 직렬화 형식을 받아들일 때는 그 인코딩이 유연성, 성능, 그리고 
정확성 관점에서 적절하다는 판단이 서야 한다.
> 기본 직렬화 형식은 그 객체의 물리적 표현이 논리적 내용과 동일할 때만 적절하다. 
###### 객체의 물리적 표현 형태가 논리적 내용과 많이 다를 경우 기본 직렬화 형식을 그대로 받아들이면 생기는 문제
* 공개 API가 현재 내부 표현 형태에 영원히 종속된다. 
* 너무 많은 공간을 차지하는 문제가 생길 수 있다.
* 너무 많은 시간을 소비하는 문제가 생길 수 있다.
* 스택 오버플로문제가 생길 수 있다.
> 기본 직렬화 형식 사용 여부에 상관없이, 객체를 직렬화 할 때는 객체의 상태 전부를 읽는 메서드에 적용할 동기화 수단을 반드시 적용해야 한다.

> 어떤 직렬화 형식을 이용하건, 직렬화 가능 클래스를 구현할 때는 직렬 버전 UID(serial version UID)를 명시적으로 선언해야 한다. 그러면 직렬 버전 UID 때문에 
생길 수 있는 잠재적 호환성 문제가 사라진다. 성능이 조금 개선되는 효과도 있다.
###### 요약
직렬화 가능한 클래스를 만들기로 했다면, 직렬화 형식에 대해서도 심각하게 고민해야 한다. 기본 직렬화 형식은 그 형태가 객체의 논리적 상태에 부합할 때만 이용해야 한다. 
그렇지 않으면 객체의 논리적 상태를 적절히 표현하는 사용자 정의 직렬화 형식을 만드는 것이 좋다. 외부로 공개되는 메서드를 설계하는 데 많은 시간을 쓰는 
것처럼, 직렬화 형식을 설계할 때도 그만한 시간을 써야 한다. 일단 공개된 메서드는 향후 버전에서 제거할 수 없듯이, 직렬화 형식에 포함시킨 필드는 나중에 제거할 수 없다. 
직렬화 호환성을 보장하기 위해서다. 직렬화 형식을 잘못 선택하면, 클래스의 복잡성과 성능 측면에 돌이킬 수 없는 악영향을 끼치게 된다.
<hr/>

### 규칙 76. readObject 메서드는 방어적으로 구현하라
간단히 말하면, readObject는 바이트 스트림을 인자로 받는 생성자다. 일반적으로 이 바이트 스트림은 정상적인 과정을 통해 만들어진 객체를 직렬화한 결과다. 문제는 인공적으로 만들어진 바이트 스트림을 readObject에 인자로 넘길 때 생긴다.
> 객체를 역으로 직렬화할 때는 클라이언트가 가질 수 없어야 하는 개체 참조를 담은 모든 필드를 방어적으로 복사하도록 해야 한다.

> 따라서 private로 선언된 변경 가능 컴포넌트가 있는 모든 직렬화 가능 변경 불가능 클래스는 해당 컴포넌트들을 readObject 메서드 안에서 방어적으로 복사해야 한다. 
###### 요약
readObject 메서드를 구현할 때는 public 생성자를 구현할 때와 같은 마음가짐을 가져야 한다. 어떤 바이트 스트림이 주어지더라도 유효한 객체가 생성될 수 있도록 해야 한다. 바이트 스트림이 실제로 직렬화된 객체일 것이라 가정하면 안된다. 
###### 안전한 readObject 메서드를 구현하고자 할 때 따라야 하는 지침
* private로 남아있어야 하는 객체 참조 필드를 가진 클래스는 그런 필드가 가리키는 객체를 방어적으로 복사해야 한다. 변경 불가능 클래스의 변경 가능 컴포넌트가 이 범주에 해당한다.
* 불변식을 검사해서 위반된 사실이 감지될 경우 InvalidObjectException을 던져야 한다. 불변식 검사는 방어적 복사 이후에 시행해야 한다.
* 만일 객체를 완전히 역직렬화 한 다음에 전체 객체 그래프의 유효성을 검사해야 한다면, ObjectInputValidation 인터페이스를 이용할 수 있다.
* 직접적이건 간접적이건, 재정의 가능 메서드를 호출하지 말아야 한다.
<hr/>

### 규칙 77. 개체 통제가 필요하다면 readResolve 대신 enum 자료형을 이용하라
선언부에 "implements Serializable"을 붙이는 순간 이 클래스는 더 이상 싱글턴 클래스가 아니다. 기본 직렬화 형태를 쓰건, 사용자 정의 직렬화 형식을 이용하건 상관없으며, 클래스에 명시적으로 readObject 메서드가 정의되어 있는지의 여부와도 상관이 없다. 모든 readObject 메서드는 새로 생성된 객체를 반환하는데, 이 객체는 클래스가 초기화될 당시에 만들어진 객체와 같은 객체가 아니다.

readResolve를 이용하면 readObject가 만들어낸 객체를 다른 것으로 대체할 수 있다. 역직렬화할 객체의 클래스에 제대로 선언된 readResolve 메서드가 정의되어 있는 경우, 역직렬화가 끝나서 만들어진 객체에 대해 이 메서드가 호출된다. 새로 만들어진 객체 대신, 이 메서드가 반환하는 객체가 사용자에게 돌아간다. 대부분의 경우, readResolve 호출이 끝나고 나면 readObject가 만든 객체에 대한 참조는 사라지므로, 바로 쓰레기 수집(garbage collection)이 가능해 진다.

하지만 위의 방법도 싱글턴에 위반되는 경우가 나올 수 있다. 이는 원소가 하나인 enum 자료형으로 해결할 수 있다. 
> 직렬화가 가능한 객체 통제 클래스를 enum으로 구현하면, 선언된 상수 이외의 다른 객체는 존재할 수 없다는 확실한 보장이 생긴다. 
###### 요약
개체 수와 관련된 불변식을 강제하고 싶을 때는 가능하면 enum을 이용하는 것이 좋다. 그럴 상황이 아닌데도 직렬화가 가능하며 개체 수 통제가 가능한 클래스가 필요하다면, 반드시 readResolve 메서드를 구현해야 할 뿐 아니라 클래스의 모든 객체 필드는 기본 자료형으로 하거나 아니면 transient로 선언해야 한다.
<hr/>

### 규칙 78. 직렬화된 객체 대신 직렬화 프락시를 고려해 보라
Serializable 인터페이스를 구현하겠다는 결정을 내리게 되면 버그나 보안 결함이 생길 가능성이 높아진다. 일반 생성자 대신 언어 외적인 메커니즘을 통해 객체를 생성할 수 있게 되기 때문이다. 하지만 이런 위험을 크게 줄일 수 있는 기술이 하나 있다. **직렬화 프락시 패턴**이다.

우선, 바깥 클래스 객체의 논리적 상태를 간결하게 표현하는 직렬화 가능 클래스를 private static 중첩 클래스로 설계한다. 이 중첩 클래스를 **직렬화 프락시**라고 부르는데, 바깥 클래스를 인자 자료형으로 사용하는 생성자를 하나만 가진다. 이 생성자는 인자에서 데이터를 복사하기만 한다. 일관성 검사를 할 필요도 없고, 방어적 복사를 할 필요도 없다. 설계상, 직렬화 프락시의 기본 직렬화 형식은 바깥 클래스의 완벽한 직렬화 형태다. 바깥 클래스뿐 아니라 직렬화 프락시도 반드시 Serializable 인터페이스를 구현한다고 선언되어야 한다.
> 직렬화 프락시 패턴을 이용하면 진정한 변경 불가능 클래스로 만들 수 있으며, 직렬화 공격의 대상이 될 필드가 무엇인지 알아내려 고민할 필요도 없고, 직렬화 도중에 명시적으로 유효성 검사를 할 필요도 없다. 뿐만아니라 역직렬화된 객체가 애초에 직렬화된 객체와 다른 클래스가 되도록 만들 수 있다.
###### 직렬화 프락시 패턴의 제약
1. 클라이언트가 확장할 수 있는 클래스에는 적용할 수 없는 기법이다.
2. 객체 그래프에 순환되는 부분이 있는 클래스에는 적용할 수 없다.
###### 요약
클라이언트가 확장할 수 없는 클래스에 readObject나 writeObject를 구현해야 할 때는 직렬화 프락시 패턴 도입을 고려해 봐야 한다. 이 패턴은 단순하지 않은 불변식을 만족해야 하는 객체를 안정적으로 직렬화하는 가장 쉬운 방법이다.
