# 모든 객체의 공통 메서드
Object는 객체 생성이 가능한 클래스이긴 하지만 기본적으로는 상속받아서 사용하도록 설계된 클래스이다. Object에 정의된 비-final메서드(equals, hashCode, 
toString, clone, finalize)에는 명시적인 일반 규약이 있다. 재정의하도록 설계된 메서드들이기 때문이다. 이 메서드들을 재정의하는 클래스는 그 일반 규약을 
따라야 한다. 그렇지 않은 클래스를 HashMap이나 HashSet처럼 해당 규약에 의존하는 클래스와 함께 사용하면 문제가 생긴다.
<hr/>

### 규칙 8. equals를 재정의할 때는 일반 규약을 따르라
###### equals 메서드를 재정의하지 않는 경우
* 각각의 객체가 고유할 때
* 클래스에 "논리적 동일성" 검사 방법이 있건 없건 상관없을 때
* 상위 클래스에서 재정의한 equals가 하위 클래스에서 사용하기에도 적당할 때
* 클래스가 private 또는 package-private로 선언되었고, equals 메서드를 호출할 일이 없을 때
###### equals 메서드를 재정의하는 경우
* 객체 동일성이 아닌 논리적 동일성의 개념을 지원하는 클래스일 때
* 상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못할 때
* 값 클래스일 때(Integer나 Date처럼, 단순히 어떤 값을 표현하는 클래스)
###### equals 메서드를 정의할 때 준수해야 하는 일반 규약
* 반사성: null이 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환한다.
* 대칭성: null이 아닌 참자 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환한다.
* 추이성: null이 아닌 참조 x, y, z가 있을 때, x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true이다.
* 일관성: null이 아닌 참조 x와 y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다.
* null이 아닌 참조 x에 대해서, x.equals(null)은 항상 false이다.
> equals가 따라야 할 규약을 어기면, 그 객체를 만난 다른 객체들이 어떻게 행동할지 예측할 수 없게 된다.
###### 훌륭한 equals 메서드를 구현하기 위해 따라야 할 지침들
* == 연산자를 사용하여 equals의 인자가 자기 자신인지 검사하라. 만일 그렇다면, true를 반환하라.
* instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사하라. 그렇지 않다면 false를 반환하라.
* equals의 인자를 정확한 자료형으로 변환하라.
* "중요" 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다. 모두 일치하는 경우에는 true를 반환하고, 그렇지 않은 경우에는 false를 반환한다.
* equals 메서드 구현을 끝냈다면, 대칭성, 추이성, 일관성의 세 속성이 만족되는지 검토하라.
* equals를 구현할 때는 hashCode도 재정의하라.
* equals 메서드의 인자 형을 Object에서 다른 것으로 바꾸지 마라.
<hr/>

### 규칙 9. equals를 재정의할 때는 반드시 hashCode도 재정의하라
많은 버그가 hashCode 메서드를 재정의하지 않아서 생긴다. equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야 한다.
###### Object 클래스의 일반 규약
* 응용프로그램 실행 중에 같은 객체의 hashCode를 여러 번 호출하는 경우, equals가 사용하는 정보들이 변경되지 않았다면, 언제나 동일한 정수가 반환되어야 한다. 
다만 프로그램이 종료되었다가 다시 실행되어도 같은 값이 나올 필요는 없다.
* equals(Object) 메서드가 같다고 판정한 두 객체의 hashCode 값은 같아야 한다.
* equals(Object) 메서드가 다르다고 판정한 두 객체의 hashCode 값은 꼭 다를 필요는 없다. 그러나 서로 다른 hashCode 값이 나오면 해시 테이블의 성능이 
향상될 수 있다는 점은 이해하고 있어야 한다.
###### 이상적인 해시 함수에 '가까운'함수를 만드는 법
* 1.17과 같은 0이 아닌 상수를 result라는 이름의 int 변수에 저장한다.
* 2.객체 안에 있는 모든 중요 필드 f에 대해서(equals 메서드가 사용하는 필드들) 아래의 절차를 시행한다.
  * A.해당 필드에 대한 int 해시 코드 c를 계산한다.
    * (1)필드가 boolean이면 (f ? 1 : 0)을 계산한다.
    * (2)필드가 byte, char, short, int 중 하나이면 (int) f를 계산한다.
    * (3)필드가 long이면 (int)(f ^ (f >>> 32))를 계산한다.
    * (4)필드가 float이면 Float.floatToIntBits(f)를 계산한다.
    * (5)필드가 double이면 Double.doubleToLongBits(f)를 계산하고 그 결과로 얻은 long 값을 위의 세 번째 절차에 따라 해시 코드로 변환한다.
    * (6)필드가 객체 참조이고 equals 메서드가 해당 필드의 equals 메서드를 재귀적으로 호출하는 경우에는 해당 필드의 hashCode 메서드를 재귀적으로 호출하여 
    해시 코드를 계산한다. 좀 더 복잡한 비교가 필요한 경우에는 해당 필드의 "대표 형태"를 계산한 다음, 대표 형태에 대해 hashCode를 호출한다. 필드 값이 null인 경우에는 
    0을 반환한다.
    * (7)필드가 배열인 경우에는 배열의 각 원소가 별도 필드인 것처럼 계산한다. 즉, 각각의 중요 원소에 대해서 방금 설명한 규칙들을 재귀적으로 적용해 해시 코드를 계산하고, 그 결과를 
    절차 2.B.와 같이 결합한다. 배열 내의 모든 원소가 중요하다면 JDK 1.5부터 제공되는 Arrays.hashCode 메서드 가운데 하나를 사용할 수도 있다.
  * B.위의 절차 A에서 계산된 해시 코드 c를 result에 다음과 같이 결합한다. ```result = 31* result + c;```
* 3.result를 반환한다.
* 4.hashCode 구현이 끝났다면, 동치 관계에 있는 객체의 해시 코드 값이 똑같이 계산되는지 점검하라. 단위 테스트를 작성해서 생각대로 되는지 확인하라. 동치 관계의 객체인데 해시 코드 값이 서로 
다르다면 원인을 알아내서 고쳐라.
> 성능을 개선하려고 객체의 중요 부분을 해시 코드 계산 과정에서 생략하면 안 된다.
<hr/>

### 규칙 10. toString은 항상 재정의하라
java.lang.Object 클래스가 toString 메서드를 제공하긴 하지만, 이 메서드가 반환하는 문자열은 일반적으로는 사용자가 보려는 문자열이 아니다. 클래스 이름 다음에 @ 기호와 16진수로 표현된 해시 코드가 붙은 문자열로, "PhoneNumber@163b91"과 같은 형태다.
> equals와 hashCode의 일반 규약을 지키는 것보다는 덜 중요하지만, toString을 잘 만들어 놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다.

> 가능하다면 toString 메서드는 객체 내의 중요 정보를 전부 담아 반환해야 한다.

> toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에, 어떤 의도인지는 문서에 분명하게 남겨야 한다.(주석을 이용)

> 문자열 형식을 명시하건 그렇지 않건 간에, toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해서 가져올 수 있도록 한다.
<hr/>

### 규칙 11. clone을 재정의할 때는 신중하라
Cloneable은 어떤 객체가 복제(clone)를 허용한다는 사실을 알리는 데 쓰려고 고안된 믹스인 인터페이스다. 불행히도 당초 목적에는 부합하지 못하고 있다. 이 인터페이스에는 clone 메서드가 없으며, Object의 clone 메서드는 protected로 선언되어 있다. 리플렉션을 사용하지 않고는 Cloneable을 구현한 객체라 해도 clone 메서드르르 호출할 방법이 없다. 리플렉션을 사용한 호출도 실패할 가능성이 있는데, 해당 객체에 호출 가능한 clone 메서드가 구현되어 있으리라는 보장이 없기 때문이다.

Cloneable은 protected로 선언된 Object의 clone 메서드가 어떻게 동작할지 정한다. 만일 어떤 클래스가 Cloneable을 구현하면, Object의 clone 메서드는 해당 객체를 필드 단위로 복사한 객체를 반환한다.
* clone 메서드의 일반 규약
```
x.clone() != x
// 위의 조건은 참이어야 한다.

x.clone().getClass() == x.getClass()
// 위의 조건은 참이 되겠지만, 반드시 그래야 하는 것은 아니다.

x.clone().equals(x)
// 위의 조건은 참이 되겠지만, 반드시 그래야 하는 것은 아니다.
```
> 객체를 복사하면 보통 같은 클래스의 새로운 객체가 만들어지는데, 내부 자료 구조까지 복사해야 될 수도 있다. 어떤 생성자도 호출되지 않는다.
* 비-final 클래스에 clone을 재정의할 때는 반드시 super.clone을 호출해 얻은 객체를 반환해야 한다.
* 실질적으로 Cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 한다.
* 사실상, clone 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시키는 일이 없도록 해야 하고, 복사본의 불변식도 제대로 만족시켜야 한다.
* clone의 아키텍처는 변경 가능한 객체를 참조하는 final 필드의 일반적 용법과 호환되지 않는다.
> 객체 복제를 지원하는 좋은 방법은, 복사 생성자나 복사 팩터리를 제공하는 것이다.
<hr/>

### 규칙 12. Comparable 구현을 고려하라
compartTo 메서드는 Object에 선언되어 있지 않다. Comparable 인터페이스에 포함된 유일한 메서드다. Object의 equals 메서드와 특성은 비슷하지만, 단순한 동치성 검사 이외에 순서 비교가 가능하다.
###### compareTo 메서드의 일반 규약
본 메서드는 이 객체와 인자로 주어진 객체를 비교한다. 이 객체의 값이 인자로 주어진 객체보다 작으면 음수를, 같으면 0을, 크면 양수를 반환한다. 인자로 전달된 객체의 자료형이 이 객체와 비교 불가능한 자료형인 경우에는 ClassCastException 예외를 던진다.

아래의 명세에 등장하는 sgn(expression)은 수학에서의 signum 함수를 나타내는 것으로, -1, 0, 1 가운데 한 값을 반환한다. 어떤 값이 반환될지는 expression의 값이 음수인지, 0인지, 양수인지에 따라서 결정된다.
* compareTo를 구현할 때는 모든 x와 y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))가 만족되도록 해야 한다.
* compareTo를 구현할 때는 추이성이 만족되도록 해야 한다. 즉, (x.compareTo(y) > 0 && y.compareTo(z) >0)이면 x.compareTo(z) > 0이어야 한다.
* x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))의 관계가 모든 z에 대해 성립하도록 해야 한다.
* 강력히 추천하지만 절대적으로 요구되는 것은 아닌 조건 하나는 (x.compareTo(y) == 0) == (x.equals(y))이다.
> 클래스에 선언된 중요 필드가 여러 개인 경우, 필드 비교 순서가 중요하다. 가장 중요한 필드부터 시작해서 차례로 비교해야 한다.
