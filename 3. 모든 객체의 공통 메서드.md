# 모든 객체의 공통 메서드
Object는 객체 생성이 가능한 클래스이긴 하지만 기본적으로는 상속받아서 사용하도록 설계된 클래스이다. Object에 정의된 비-final메서드(equals, hashCode, 
toString, clone, finalize)에는 명시적인 일반 규약이 있다. 재정의하도록 설계된 메서드들이기 때문이다. 이 메서드들을 재정의하는 클래스는 그 일반 규약을 
따라야 한다. 그렇지 않은 클래스를 HashMap이나 HashSet처럼 해당 규약에 의존하는 클래스와 함께 사용하면 문제가 생긴다.
<hr/>

### 규칙 8. equals를 재정의할 때는 일반 규약을 따르라
###### equals 메서드를 재정의하지 않는 경우
* 각각의 객체가 고유할 때
* 클래스에 "논리적 동일성" 검사 방법이 있건 없건 상관없을 때
* 상위 클래스에서 재정의한 equals가 하위 클래스에서 사용하기에도 적당할 때
* 클래스가 private 또는 package-private로 선언되었고, equals 메서드를 호출할 일이 없을 때
###### equals 메서드를 재정의하는 경우
* 객체 동일성이 아닌 논리적 동일성의 개념을 지원하는 클래스일 때
* 상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못할 때
* 값 클래스일 때(Integer나 Date처럼, 단순히 어떤 값을 표현하는 클래스)
###### equals 메서드를 정의할 때 준수해야 하는 일반 규약
* 반사성: null이 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환한다.
* 대칭성: null이 아닌 참자 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환한다.
* 추이성: null이 아닌 참조 x, y, z가 있을 때, x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true이다.
* 일관성: null이 아닌 참조 x와 y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다.
* null이 아닌 참조 x에 대해서, x.equals(null)은 항상 false이다.
> equals가 따라야 할 규약을 어기면, 그 객체를 만난 다른 객체들이 어떻게 행동할지 예측할 수 없게 된다.
###### 훌륭한 equals 메서드를 구현하기 위해 따라야 할 지침들
* == 연산자를 사용하여 equals의 인자가 자기 자신인지 검사하라. 만일 그렇다면, true를 반환하라.
* instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사하라. 그렇지 않다면 false를 반환하라.
* equals의 인자를 정확한 자료형으로 변환하라.
* "중요" 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다. 모두 일치하는 경우에는 true를 반환하고, 그렇지 않은 경우에는 false를 반환한다.
* equals 메서드 구현을 끝냈다면, 대칭성, 추이성, 일관성의 세 속성이 만족되는지 검토하라.
* equals를 구현할 때는 hashCode도 재정의하라.
* equals 메서드의 인자 형을 Object에서 다른 것으로 바꾸지 마라.
<hr/>

### 규칙 9. equals를 재정의할 때는 반드시 hashCode도 재정의하라
많은 버그가 hashCode 메서드를 재정의하지 않아서 생긴다. equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야 한다.
###### Object 클래스의 일반 규약
* 응용프로그램 실행 중에 같은 객체의 hashCode를 여러 번 호출하는 경우, equals가 사용하는 정보들이 변경되지 않았다면, 언제나 동일한 정수가 반환되어야 한다. 
다만 프로그램이 종료되었다가 다시 실행되어도 같은 값이 나올 필요는 없다.
* equals(Object) 메서드가 같다고 판정한 두 객체의 hashCode 값은 같아야 한다.
* equals(Object) 메서드가 다르다고 판정한 두 객체의 hashCode 값은 꼭 다를 필요는 없다. 그러나 서로 다른 hashCode 값이 나오면 해시 테이블의 성능이 
향상될 수 있다는 점은 이해하고 있어야 한다.
###### 이상적인 해시 함수에 '가까운'함수를 만드는 법
* 1.17과 같은 0이 아닌 상수를 result라는 이름의 int 변수에 저장한다.
* 2.객체 안에 있는 모든 중요 필드 f에 대해서(equals 메서드가 사용하는 필드들) 아래의 절차를 시행한다.
  * A.해당 필드에 대한 int 해시 코드 c를 계산한다.
    * (1)필드가 boolean이면 (f ? 1 : 0)을 계산한다.
    * (2)필드가 byte, char, short, int 중 하나이면 (int) f를 계산한다.
    * (3)필드가 long이면 (int)(f ^ (f >>> 32))를 계산한다.
    * (4)필드가 float이면 Float.floatToIntBits(f)를 계산한다.
    * (5)필드가 double이면 Double.doubleToLongBits(f)를 계산하고 그 결과로 얻은 long 값을 위의 세 번째 절차에 따라 해시 코드로 변환한다.
    * (6)필드가 객체 참조이고 equals 메서드가 해당 필드의 equals 메서드를 재귀적으로 호출하는 경우에는 해당 필드의 hashCode 메서드를 재귀적으로 호출하여 
    해시 코드를 계산한다. 좀 더 복잡한 비교가 필요한 경우에는 해당 필드의 "대표 형태"를 계산한 다음, 대표 형태에 대해 hashCode를 호출한다. 필드 값이 null인 경우에는 
    0을 반환한다.
    * (7)필드가 배열인 경우에는 배열의 각 원소가 별도 필드인 것처럼 계산한다. 즉, 각각의 중요 원소에 대해서 방금 설명한 규칙들을 재귀적으로 적용해 해시 코드를 계산하고, 그 결과를 
    절차 2.B.와 같이 결합한다. 배열 내의 모든 원소가 중요하다면 JDK 1.5부터 제공되는 Arrays.hashCode 메서드 가운데 하나를 사용할 수도 있다.
  * B.위의 절차 A에서 계산된 해시 코드 c를 result에 다음과 같이 결합한다. ```result = 31* result + c;```
* 3.result를 반환한다.
* 4.hashCode 구현이 끝났다면, 동치 관계에 있는 객체의 해시 코드 값이 똑같이 계산되는지 점검하라. 단위 테스트를 작성해서 생각대로 되는지 확인하라. 동치 관계의 객체인데 해시 코드 값이 서로 
다르다면 원인을 알아내서 고쳐라.
> 성능을 개선하려고 객체의 중요 부분을 해시 코드 계산 과정에서 생략하면 안 된다.
<hr/>

### 규칙 10. toString은 항상 재정의하라
